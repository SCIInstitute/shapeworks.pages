<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Shapeworks Studio: Eigen::SparseQR&lt; _MatrixType, _OrderingType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="splash.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shapeworks Studio
   &#160;<span id="projectnumber">2.1</span>
   </div>
   <div id="projectbrief">Shape analysis software suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="https://github.com/SCIInstitute/ShapeWorksStudio"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Eigen</b></li><li class="navelem"><a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_eigen_1_1_sparse_q_r-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::SparseQR&lt; _MatrixType, _OrderingType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse left-looking rank-revealing <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization.  
 <a href="class_eigen_1_1_sparse_q_r.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Eigen::SparseQR&lt; _MatrixType, _OrderingType &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_eigen_1_1_sparse_q_r__coll__graph.png" border="0" usemap="#_eigen_1_1_sparse_q_r_3_01___matrix_type_00_01___ordering_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_eigen_1_1_sparse_q_r_3_01___matrix_type_00_01___ordering_type_01_4_coll__map" id="_eigen_1_1_sparse_q_r_3_01___matrix_type_00_01___ordering_type_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad358268460ec00e9cd058846a2cbb6f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad358268460ec00e9cd058846a2cbb6f5"></a>
typedef _MatrixType&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:ad358268460ec00e9cd058846a2cbb6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2f072bb9206c83f6046f25fcc4dbbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b2f072bb9206c83f6046f25fcc4dbbe"></a>
typedef _OrderingType&#160;</td><td class="memItemRight" valign="bottom"><b>OrderingType</b></td></tr>
<tr class="separator:a6b2f072bb9206c83f6046f25fcc4dbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b368cb269850c36954d938a9e216ee9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b368cb269850c36954d938a9e216ee9"></a>
typedef MatrixType::Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b></td></tr>
<tr class="separator:a1b368cb269850c36954d938a9e216ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30621d97daf0e3ef2337b7c37cb8f3d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30621d97daf0e3ef2337b7c37cb8f3d9"></a>
typedef MatrixType::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:a30621d97daf0e3ef2337b7c37cb8f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689da977577579c26e208e2d625b6ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689da977577579c26e208e2d625b6ac8"></a>
typedef MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b></td></tr>
<tr class="separator:a689da977577579c26e208e2d625b6ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b3b82a7220f11438042dff68c744a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b3b82a7220f11438042dff68c744a0"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, ColMajor, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>QRMatrixType</b></td></tr>
<tr class="separator:a43b3b82a7220f11438042dff68c744a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc915eac3d058421af43318f6757bb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fc915eac3d058421af43318f6757bb9"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Index, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a4fc915eac3d058421af43318f6757bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c9c4b7cf2b31182acf410253682f07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97c9c4b7cf2b31182acf410253682f07"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:a97c9c4b7cf2b31182acf410253682f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db58c91d0e55aad8cb7c0c7c57bf72f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7db58c91d0e55aad8cb7c0c7c57bf72f"></a>
typedef <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationMatrix</a>&lt; Dynamic, Dynamic, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PermutationType</b></td></tr>
<tr class="separator:a7db58c91d0e55aad8cb7c0c7c57bf72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac50f705d686d4bc687ce6acbc76447d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac50f705d686d4bc687ce6acbc76447d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseQR</b> (const MatrixType &amp;mat)</td></tr>
<tr class="separator:ac50f705d686d4bc687ce6acbc76447d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaf52b7543de4d55c58c8f830c2aeb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedaf52b7543de4d55c58c8f830c2aeb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compute</b> (const MatrixType &amp;mat)</td></tr>
<tr class="separator:aedaf52b7543de4d55c58c8f830c2aeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b425ddb1358c914d764cde48853a4f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a4b425ddb1358c914d764cde48853a4f6">analyzePattern</a> (const MatrixType &amp;mat)</td></tr>
<tr class="memdesc:a4b425ddb1358c914d764cde48853a4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocessing step of a <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization.  <a href="#a4b425ddb1358c914d764cde48853a4f6">More...</a><br /></td></tr>
<tr class="separator:a4b425ddb1358c914d764cde48853a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a34bacf05bd30a1dacbccad9f03c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a55a34bacf05bd30a1dacbccad9f03c6d">factorize</a> (const MatrixType &amp;mat)</td></tr>
<tr class="memdesc:a55a34bacf05bd30a1dacbccad9f03c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the numerical <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization of the input matrix.  <a href="#a55a34bacf05bd30a1dacbccad9f03c6d">More...</a><br /></td></tr>
<tr class="separator:a55a34bacf05bd30a1dacbccad9f03c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb9120e3f108695e79a72994cb8a914"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#adfb9120e3f108695e79a72994cb8a914">rows</a> () const </td></tr>
<tr class="separator:adfb9120e3f108695e79a72994cb8a914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de0ad4547cf7fd1d391f99575eabd1b"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a2de0ad4547cf7fd1d391f99575eabd1b">cols</a> () const </td></tr>
<tr class="separator:a2de0ad4547cf7fd1d391f99575eabd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085ba4cbf32ff1598e437d939f86556"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_sparse_matrix.html">QRMatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#ac085ba4cbf32ff1598e437d939f86556">matrixR</a> () const </td></tr>
<tr class="separator:ac085ba4cbf32ff1598e437d939f86556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9c12de1c84aee249433d7764caee63"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#afe9c12de1c84aee249433d7764caee63">rank</a> () const </td></tr>
<tr class="separator:afe9c12de1c84aee249433d7764caee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfbc1f00bd3ef3e5eece6eb4aea237d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_sparse_q_r_matrix_q_return_type.html">SparseQRMatrixQReturnType</a>&lt; <a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a7bfbc1f00bd3ef3e5eece6eb4aea237d">matrixQ</a> () const </td></tr>
<tr class="separator:a7bfbc1f00bd3ef3e5eece6eb4aea237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d4dd24da7e09832dac94f510696c95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a54d4dd24da7e09832dac94f510696c95">colsPermutation</a> () const </td></tr>
<tr class="separator:a54d4dd24da7e09832dac94f510696c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1014cfe3e3ecbc6e6496e2c3962933"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#ada1014cfe3e3ecbc6e6496e2c3962933">lastErrorMessage</a> () const </td></tr>
<tr class="separator:ada1014cfe3e3ecbc6e6496e2c3962933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c9157079f78c23a2a080130f685ee4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85c9157079f78c23a2a080130f685ee4"></a>
template&lt;typename Rhs , typename Dest &gt; </td></tr>
<tr class="memitem:a85c9157079f78c23a2a080130f685ee4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_solve</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Rhs &gt; &amp;B, <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Dest &gt; &amp;dest) const </td></tr>
<tr class="separator:a85c9157079f78c23a2a080130f685ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7bfa65f99e3ef91ed58ea663a850a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#adb7bfa65f99e3ef91ed58ea663a850a1">setPivotThreshold</a> (const RealScalar &amp;threshold)</td></tr>
<tr class="separator:adb7bfa65f99e3ef91ed58ea663a850a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b8fa7268cd8ba8af135ce42684c05"><td class="memTemplParams" colspan="2">template&lt;typename Rhs &gt; </td></tr>
<tr class="memitem:a6d8b8fa7268cd8ba8af135ce42684c05"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_eigen_1_1internal_1_1solve__retval.html">internal::solve_retval</a>&lt; <a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a>, Rhs &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a6d8b8fa7268cd8ba8af135ce42684c05">solve</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Rhs &gt; &amp;B) const </td></tr>
<tr class="separator:a6d8b8fa7268cd8ba8af135ce42684c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da7d5b7e70d06e54ab0d48955e61452"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1da7d5b7e70d06e54ab0d48955e61452"></a>
template&lt;typename Rhs &gt; </td></tr>
<tr class="memitem:a1da7d5b7e70d06e54ab0d48955e61452"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_eigen_1_1internal_1_1sparse__solve__retval.html">internal::sparse_solve_retval</a>&lt; <a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a>, Rhs &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Rhs &gt; &amp;B) const </td></tr>
<tr class="separator:a1da7d5b7e70d06e54ab0d48955e61452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c31869fcfc19707c882347a9c77fa3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html#a7c31869fcfc19707c882347a9c77fa3f">info</a> () const </td></tr>
<tr class="memdesc:a7c31869fcfc19707c882347a9c77fa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether previous computation was successful.  <a href="#a7c31869fcfc19707c882347a9c77fa3f">More...</a><br /></td></tr>
<tr class="separator:a7c31869fcfc19707c882347a9c77fa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad77267b6694f1440733ecb207b5436b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77267b6694f1440733ecb207b5436b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort_matrix_Q</b> ()</td></tr>
<tr class="separator:ad77267b6694f1440733ecb207b5436b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a114e11edc2dab35489da8bae87a4cc75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a114e11edc2dab35489da8bae87a4cc75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isInitialized</b></td></tr>
<tr class="separator:a114e11edc2dab35489da8bae87a4cc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bd12520c89f1ec1d977f46733df424"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8bd12520c89f1ec1d977f46733df424"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_analysisIsok</b></td></tr>
<tr class="separator:ac8bd12520c89f1ec1d977f46733df424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e434fe55a648f843f5e4c75e348bb45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e434fe55a648f843f5e4c75e348bb45"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_factorizationIsok</b></td></tr>
<tr class="separator:a0e434fe55a648f843f5e4c75e348bb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f533e32f1349dc0776ed818f712847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24f533e32f1349dc0776ed818f712847"></a>
<a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_info</b></td></tr>
<tr class="separator:a24f533e32f1349dc0776ed818f712847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dfb7db82cde35cb26efda4af90c8ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50dfb7db82cde35cb26efda4af90c8ce"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_lastError</b></td></tr>
<tr class="separator:a50dfb7db82cde35cb26efda4af90c8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb35d222bfcaa70705114e83e4c815f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb35d222bfcaa70705114e83e4c815f"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">QRMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_pmat</b></td></tr>
<tr class="separator:a3eb35d222bfcaa70705114e83e4c815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71390c50833e5137612909c984453aa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71390c50833e5137612909c984453aa8"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">QRMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_R</b></td></tr>
<tr class="separator:a71390c50833e5137612909c984453aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e7e4baac8097aa2286ff76c503153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af90e7e4baac8097aa2286ff76c503153"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">QRMatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_Q</b></td></tr>
<tr class="separator:af90e7e4baac8097aa2286ff76c503153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a6f19f247613237f65b328c467454"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a816a6f19f247613237f65b328c467454"></a>
<a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_hcoeffs</b></td></tr>
<tr class="separator:a816a6f19f247613237f65b328c467454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf03fa0af7d7f03e3d86d34fc3eb7a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cf03fa0af7d7f03e3d86d34fc3eb7a1"></a>
<a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_perm_c</b></td></tr>
<tr class="separator:a3cf03fa0af7d7f03e3d86d34fc3eb7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e300573ed969fbc06dcf0d2f9f3c007"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e300573ed969fbc06dcf0d2f9f3c007"></a>
<a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_pivotperm</b></td></tr>
<tr class="separator:a3e300573ed969fbc06dcf0d2f9f3c007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d82ee61311e78baf0f51da641b3708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68d82ee61311e78baf0f51da641b3708"></a>
<a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_outputPerm_c</b></td></tr>
<tr class="separator:a68d82ee61311e78baf0f51da641b3708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d78507f2f5c20b0e84e49964f7f6663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d78507f2f5c20b0e84e49964f7f6663"></a>
RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>m_threshold</b></td></tr>
<tr class="separator:a6d78507f2f5c20b0e84e49964f7f6663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff33393a04cec953b58e0ee3fe4ecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeff33393a04cec953b58e0ee3fe4ecb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_useDefaultThreshold</b></td></tr>
<tr class="separator:abeff33393a04cec953b58e0ee3fe4ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46529756e4ff75196644415dfdc43306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46529756e4ff75196644415dfdc43306"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_nonzeropivots</b></td></tr>
<tr class="separator:a46529756e4ff75196644415dfdc43306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c58a6962f17566a4b36b818ab9c776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c58a6962f17566a4b36b818ab9c776"></a>
<a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_etree</b></td></tr>
<tr class="separator:a50c58a6962f17566a4b36b818ab9c776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5d40c6611c8440c6be0406908a7319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5d40c6611c8440c6be0406908a7319"></a>
<a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_firstRowElt</b></td></tr>
<tr class="separator:a1f5d40c6611c8440c6be0406908a7319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef52b7e7b754a39a433f74b18c7b76c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeef52b7e7b754a39a433f74b18c7b76c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isQSorted</b></td></tr>
<tr class="separator:aeef52b7e7b754a39a433f74b18c7b76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9b447255bbccd5da503ef3f77798701"><td class="memTemplParams" colspan="2"><a class="anchor" id="af9b447255bbccd5da503ef3f77798701"></a>
template&lt;typename , typename &gt; </td></tr>
<tr class="memitem:af9b447255bbccd5da503ef3f77798701"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseQR_QProduct</b></td></tr>
<tr class="separator:af9b447255bbccd5da503ef3f77798701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2e550e75a2fe256c1536cabcbda21"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6de2e550e75a2fe256c1536cabcbda21"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:a6de2e550e75a2fe256c1536cabcbda21"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SparseQRMatrixQReturnType</b></td></tr>
<tr class="separator:a6de2e550e75a2fe256c1536cabcbda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _MatrixType, typename _OrderingType&gt;<br />
class Eigen::SparseQR&lt; _MatrixType, _OrderingType &gt;</h3>

<p>Sparse left-looking rank-revealing <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization. </p>
<p>This class implements a left-looking rank-revealing <a class="el" href="class_eigen_1_1_q_r.html">QR</a> decomposition of sparse matrices. When a column has a norm less than a given tolerance it is implicitly permuted to the end. The <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization thus obtained is given by A*P = Q*R where R is upper triangular or trapezoidal.</p>
<p>P is the column permutation which is the product of the fill-reducing and the rank-revealing permutations. Use <a class="el" href="class_eigen_1_1_sparse_q_r.html#a54d4dd24da7e09832dac94f510696c95">colsPermutation()</a> to get it.</p>
<p>Q is the orthogonal matrix represented as products of Householder reflectors. Use <a class="el" href="class_eigen_1_1_sparse_q_r.html#a7bfbc1f00bd3ef3e5eece6eb4aea237d">matrixQ()</a> to get an expression and <a class="el" href="class_eigen_1_1_sparse_q_r.html#a7bfbc1f00bd3ef3e5eece6eb4aea237d">matrixQ()</a>.transpose() to get the transpose. You can then apply it to a vector.</p>
<p>R is the sparse triangular or trapezoidal matrix. The later occurs when A is rank-deficient. <a class="el" href="class_eigen_1_1_sparse_q_r.html#ac085ba4cbf32ff1598e437d939f86556">matrixR()</a>.topLeftCorner(<a class="el" href="class_eigen_1_1_sparse_q_r.html#afe9c12de1c84aee249433d7764caee63">rank()</a>, <a class="el" href="class_eigen_1_1_sparse_q_r.html#afe9c12de1c84aee249433d7764caee63">rank()</a>) always returns a triangular factor of full rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_MatrixType</td><td>The type of the sparse matrix A, must be a column-major SparseMatrix&lt;&gt; </td></tr>
    <tr><td class="paramname">_OrderingType</td><td>The fill-reducing ordering method. See the <a class="el" href="">OrderingMethods </a> module for the list of built-in and external ordering methods. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00016">16</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4b425ddb1358c914d764cde48853a4f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; MatrixType, OrderingType &gt;::analyzePattern </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preprocessing step of a <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization. </p>
<p>In this step, the fill-reducing permutation is computed and applied to the columns of A and the column elimination tree is computed as well. Only the sparcity pattern of <em>mat</em> is exploited.</p>
<dl class="section note"><dt>Note</dt><dd>In this step it is assumed that there is no empty row in the matrix <em>mat</em>. </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00264">264</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;{</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="comment">// Compute the column fill reducing ordering</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  OrderingType ord; </div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  ord(mat, m_perm_c); </div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  Index n = mat.cols();</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  Index m = mat.rows();</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  </div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="keywordflow">if</span> (!m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">size</a>())</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#a0e0fda6e84d69e02432e4770359bb532">resize</a>(n);</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>().setLinSpaced(n, 0,n-1);</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  }</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  </div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="comment">// Compute the column elimination tree of the permuted matrix</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  m_outputPerm_c = m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#acd5b0470479df2b040bfadd6937cb4c9">inverse</a>();</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <a class="code" href="namespace_eigen_1_1internal.html#a22b184331e5fb270a37d1305e95cb064">internal::coletree</a>(mat, m_etree, m_firstRowElt, m_outputPerm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>().data());</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  </div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  m_R.<a class="code" href="class_eigen_1_1_sparse_matrix.html#aa005409dfde1f6a0c0518047243f908b">resize</a>(n, n);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  m_Q.<a class="code" href="class_eigen_1_1_sparse_matrix.html#aa005409dfde1f6a0c0518047243f908b">resize</a>(m, n);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  </div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="comment">// Allocate space for nonzero elements : rough estimation</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  m_R.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a5c74c12e50696e47f2e958d672c43acd">reserve</a>(2*mat.nonZeros()); <span class="comment">//FIXME Get a more accurate estimation through symbolic factorization with the etree</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  m_Q.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a5c74c12e50696e47f2e958d672c43acd">reserve</a>(2*mat.nonZeros());</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  m_hcoeffs.<a class="code" href="class_eigen_1_1_plain_object_base.html#a18832b701979a2e5b8874fb4f900c685">resize</a>(n);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  m_analysisIsok = <span class="keyword">true</span>;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;}</div><div class="ttc" id="class_eigen_1_1_permutation_base_html_a0e0fda6e84d69e02432e4770359bb532"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#a0e0fda6e84d69e02432e4770359bb532">Eigen::PermutationBase::resize</a></div><div class="ttdeci">void resize(Index newSize)</div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00142">PermutationMatrix.h:142</a></div></div>
<div class="ttc" id="class_eigen_1_1_plain_object_base_html_a18832b701979a2e5b8874fb4f900c685"><div class="ttname"><a href="class_eigen_1_1_plain_object_base.html#a18832b701979a2e5b8874fb4f900c685">Eigen::PlainObjectBase::resize</a></div><div class="ttdeci">EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)</div><div class="ttdef"><b>Definition:</b> <a href="_plain_object_base_8h_source.html#l00232">PlainObjectBase.h:232</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a5c74c12e50696e47f2e958d672c43acd"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a5c74c12e50696e47f2e958d672c43acd">Eigen::SparseMatrix::reserve</a></div><div class="ttdeci">void reserve(Index reserveSize)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00256">SparseMatrix.h:256</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_ac637509429ed2e8aa3b846b9e02da8e4"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">Eigen::PermutationBase::size</a></div><div class="ttdeci">Index size() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00114">PermutationMatrix.h:114</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_matrix_html_a523ff8c60307b5e9f27526599185acd3"><div class="ttname"><a href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">Eigen::PermutationMatrix::indices</a></div><div class="ttdeci">const IndicesType &amp; indices() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00358">PermutationMatrix.h:358</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_acd5b0470479df2b040bfadd6937cb4c9"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#acd5b0470479df2b040bfadd6937cb4c9">Eigen::PermutationBase::inverse</a></div><div class="ttdeci">Transpose&lt; PermutationBase &gt; inverse() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00201">PermutationMatrix.h:201</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_aa005409dfde1f6a0c0518047243f908b"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#aa005409dfde1f6a0c0518047243f908b">Eigen::SparseMatrix::resize</a></div><div class="ttdeci">void resize(Index rows, Index cols)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00596">SparseMatrix.h:596</a></div></div>
<div class="ttc" id="namespace_eigen_1_1internal_html_a22b184331e5fb270a37d1305e95cb064"><div class="ttname"><a href="namespace_eigen_1_1internal.html#a22b184331e5fb270a37d1305e95cb064">Eigen::internal::coletree</a></div><div class="ttdeci">int coletree(const MatrixType &amp;mat, IndexVector &amp;parent, IndexVector &amp;firstRowElt, typename MatrixType::Index *perm=0)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_col_etree_8h_source.html#l00061">SparseColEtree.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2de0ad4547cf7fd1d391f99575eabd1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::cols </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns of the represented matrix. </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00098">98</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;{ <span class="keywordflow">return</span> m_pmat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">cols</a>();}</div><div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a60e574bcb97bd1d210c4d110529b4c89"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">Eigen::SparseMatrix::cols</a></div><div class="ttdeci">Index cols() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00121">SparseMatrix.h:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a54d4dd24da7e09832dac94f510696c95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&amp; <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::colsPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const reference to the column permutation P that was applied to A such that A*P = Q*R It is the combination of the fill-in reducing permutation and numerical column pivoting. </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00138">138</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    { </div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;      eigen_assert(m_isInitialized &amp;&amp; <span class="stringliteral">&quot;Decomposition is not initialized.&quot;</span>);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      <span class="keywordflow">return</span> m_outputPerm_c;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a55a34bacf05bd30a1dacbccad9f03c6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; MatrixType, OrderingType &gt;::factorize </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the numerical <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization of the input matrix. </p>
<p>The function <a class="el" href="class_eigen_1_1_sparse_q_r.html#a4b425ddb1358c914d764cde48853a4f6" title="Preprocessing step of a QR factorization. ">SparseQR::analyzePattern(const MatrixType&amp;)</a> must have been called beforehand with a matrix having the same sparcity pattern than <em>mat</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The sparse column-major matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00300">300</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;{</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <span class="keyword">using</span> std::abs;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  <span class="keyword">using</span> std::max;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  </div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  eigen_assert(m_analysisIsok &amp;&amp; <span class="stringliteral">&quot;analyzePattern() should be called before this step&quot;</span>);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  Index m = mat.rows();</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  Index n = mat.cols();</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  IndexVector mark(m); mark.setConstant(-1);  <span class="comment">// Record the visited nodes</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  IndexVector Ridx(n), Qidx(m);               <span class="comment">// Store temporarily the row indexes for the current column of R and Q</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  Index nzcolR, nzcolQ;                       <span class="comment">// Number of nonzero for the current column of R and Q</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  ScalarVector tval(m);                       <span class="comment">// The dense vector used to compute the current column</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="keywordtype">bool</span> found_diag;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    </div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  m_pmat = mat;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  m_pmat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a55a8c8bc53a972811bda8909b2d17443">uncompress</a>(); <span class="comment">// To have the innerNonZeroPtr allocated</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="comment">// Apply the fill-in reducing permutation lazily:</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    Index p = m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">size</a>() ? m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(i) : i;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    m_pmat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">outerIndexPtr</a>()[p] = mat.outerIndexPtr()[i]; </div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    m_pmat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ac76a65c37b2bc5043b17b9f8b6dab580">innerNonZeroPtr</a>()[p] = mat.outerIndexPtr()[i+1] - mat.outerIndexPtr()[i]; </div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  }</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  </div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="comment">/* Compute the default threshold, see : </span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">   * Tim Davis, &quot;Algorithm 915, SuiteSparseQR: Multifrontal Multithreaded Rank-Revealing</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">   * Sparse QR Factorization, ACM Trans. on Math. Soft. 38(1), 2011, Page 8:3 </span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">   */</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="keywordflow">if</span>(m_useDefaultThreshold) </div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  {</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    RealScalar max2Norm = 0.0;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) max2Norm = (max)(max2Norm, m_pmat.<a class="code" href="class_eigen_1_1_sparse_matrix_base.html#ad49129f2301063ce046ae071c82610d5">col</a>(j).norm());</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    m_threshold = 20 * (m + n) * max2Norm * NumTraits&lt;RealScalar&gt;::epsilon();</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  }</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  </div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  <span class="comment">// Initialize the numerical permutation</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  m_pivotperm.<a class="code" href="class_eigen_1_1_permutation_base.html#a6805bb75fd7966ea71895c24ff196444">setIdentity</a>(n);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  </div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  Index nonzeroCol = 0; <span class="comment">// Record the number of valid pivots</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  </div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  <span class="comment">// Left looking rank-revealing QR factorization: compute a column of R and Q at a time</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  <span class="keywordflow">for</span> (Index col = 0; col &lt; n; ++col)</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    mark.setConstant(-1);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    m_R.startVec(col);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    m_Q.startVec(col);</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    mark(nonzeroCol) = col;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    Qidx(0) = nonzeroCol;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    nzcolR = 0; nzcolQ = 1;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    found_diag = <span class="keyword">false</span>;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    tval.setZero(); </div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    </div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="comment">// Symbolic factorization: find the nonzero locations of the column k of the factors R and Q, i.e.,</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="comment">// all the nodes (with indexes lower than rank) reachable through the column elimination tree (etree) rooted at node k.</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="comment">// Note: if the diagonal entry does not exist, then its contribution must be explicitly added,</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="comment">// thus the trick with found_diag that permits to do one more iteration on the diagonal element if this one has not been found.</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">typename</span> MatrixType::InnerIterator itp(m_pmat, col); itp || !found_diag; ++itp)</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;      Index curIdx = nonzeroCol ;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;      <span class="keywordflow">if</span>(itp) curIdx = itp.row();</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;      <span class="keywordflow">if</span>(curIdx == nonzeroCol) found_diag = <span class="keyword">true</span>;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;      </div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <span class="comment">// Get the nonzeros indexes of the current column of R</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      Index st = m_firstRowElt(curIdx); <span class="comment">// The traversal of the etree starts here </span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <span class="keywordflow">if</span> (st &lt; 0 )</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;      {</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        m_lastError = <span class="stringliteral">&quot;Empty row found during numerical factorization&quot;</span>;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea580b2a3cafe585691e789f768fb729bf">InvalidInput</a>;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      }</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      <span class="comment">// Traverse the etree </span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;      Index bi = nzcolR;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      <span class="keywordflow">for</span> (; mark(st) != col; st = m_etree(st))</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;      {</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        Ridx(nzcolR) = st;  <span class="comment">// Add this row to the list,</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        mark(st) = col;     <span class="comment">// and mark this row as visited</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        nzcolR++;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;      }</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;      <span class="comment">// Reverse the list to get the topological ordering</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      Index nt = nzcolR-bi;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;      <span class="keywordflow">for</span>(Index i = 0; i &lt; nt/2; i++) std::swap(Ridx(bi+i), Ridx(nzcolR-i-1));</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;       </div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;      <span class="comment">// Copy the current (curIdx,pcol) value of the input matrix</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;      <span class="keywordflow">if</span>(itp) tval(curIdx) = itp.value();</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;      <span class="keywordflow">else</span>    tval(curIdx) = Scalar(0);</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;      </div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;      <span class="comment">// Compute the pattern of Q(:,k)</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      <span class="keywordflow">if</span>(curIdx &gt; nonzeroCol &amp;&amp; mark(curIdx) != col ) </div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      {</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        Qidx(nzcolQ) = curIdx;  <span class="comment">// Add this row to the pattern of Q,</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        mark(curIdx) = col;     <span class="comment">// and mark it as visited</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        nzcolQ++;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      }</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    }</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="comment">// Browse all the indexes of R(:,col) in reverse order</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordflow">for</span> (Index i = nzcolR-1; i &gt;= 0; i--)</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    {</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;      Index curIdx = m_pivotperm.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(Ridx(i));</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;      </div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;      <span class="comment">// Apply the curIdx-th householder vector to the current column (temporarily stored into tval)</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      Scalar tdot(0);</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      </div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      <span class="comment">// First compute q&#39; * tval</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;      tdot = m_Q.<a class="code" href="class_eigen_1_1_sparse_matrix_base.html#ad49129f2301063ce046ae071c82610d5">col</a>(curIdx).dot(tval);</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      tdot *= m_hcoeffs(curIdx);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;      </div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;      <span class="comment">// Then update tval = tval - q * tau</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;      <span class="comment">// FIXME: tval -= tdot * m_Q.col(curIdx) should amount to the same (need to check/add support for efficient &quot;dense ?= sparse&quot;)</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">typename</span> QRMatrixType::InnerIterator itq(m_Q, curIdx); itq; ++itq)</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        tval(itq.row()) -= itq.value() * tdot;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="comment">// Detect fill-in for the current column of Q</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;      <span class="keywordflow">if</span>(m_etree(Ridx(i)) == nonzeroCol)</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;      {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> QRMatrixType::InnerIterator itq(m_Q, curIdx); itq; ++itq)</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        {</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;          Index iQ = itq.row();</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;          <span class="keywordflow">if</span> (mark(iQ) != col)</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;          {</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            Qidx(nzcolQ++) = iQ;  <span class="comment">// Add this row to the pattern of Q,</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            mark(iQ) = col;       <span class="comment">// and mark it as visited</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;          }</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        }</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      }</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    } <span class="comment">// End update current column</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        </div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="comment">// Compute the Householder reflection that eliminate the current column</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="comment">// FIXME this step should call the Householder module.</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    Scalar tau;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    RealScalar beta;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    Scalar c0 = nzcolQ ? tval(Qidx(0)) : Scalar(0);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    </div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="comment">// First, the squared norm of Q((col+1):m, col)</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    RealScalar sqrNorm = 0.;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">for</span> (Index itq = 1; itq &lt; nzcolQ; ++itq) sqrNorm += numext::abs2(tval(Qidx(itq)));</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    </div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="keywordflow">if</span>(sqrNorm == RealScalar(0) &amp;&amp; numext::imag(c0) == RealScalar(0))</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      tau = RealScalar(0);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;      beta = numext::real(c0);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;      tval(Qidx(0)) = 1;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;     }</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    {</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;      beta = std::sqrt(numext::abs2(c0) + sqrNorm);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;      <span class="keywordflow">if</span>(numext::real(c0) &gt;= RealScalar(0))</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        beta = -beta;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      tval(Qidx(0)) = 1;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;      <span class="keywordflow">for</span> (Index itq = 1; itq &lt; nzcolQ; ++itq)</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        tval(Qidx(itq)) /= (c0 - beta);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      tau = numext::conj((beta-c0) / beta);</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        </div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="comment">// Insert values in R</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">for</span> (Index  i = nzcolR-1; i &gt;= 0; i--)</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      Index curIdx = Ridx(i);</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      <span class="keywordflow">if</span>(curIdx &lt; nonzeroCol) </div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      {</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        m_R.insertBackByOuterInnerUnordered(col, curIdx) = tval(curIdx);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        tval(curIdx) = Scalar(0.);</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      }</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    }</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">if</span>(abs(beta) &gt;= m_threshold)</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;      m_R.insertBackByOuterInner(col, nonzeroCol) = beta;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;      nonzeroCol++;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;      <span class="comment">// The householder coefficient</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      m_hcoeffs(col) = tau;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;      <span class="comment">// Record the householder reflections</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;      <span class="keywordflow">for</span> (Index itq = 0; itq &lt; nzcolQ; ++itq)</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;      {</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        Index iQ = Qidx(itq);</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        m_Q.insertBackByOuterInnerUnordered(col,iQ) = tval(iQ);</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        tval(iQ) = Scalar(0.);</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;      }    </div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    }</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      <span class="comment">// Zero pivot found: move implicitly this column to the end</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;      m_hcoeffs(col) = Scalar(0);</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      <span class="keywordflow">for</span> (Index j = nonzeroCol; j &lt; n-1; j++) </div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        std::swap(m_pivotperm.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(j), m_pivotperm.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()[j+1]);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      </div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      <span class="comment">// Recompute the column elimination tree</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;      <a class="code" href="namespace_eigen_1_1internal.html#a22b184331e5fb270a37d1305e95cb064">internal::coletree</a>(m_pmat, m_etree, m_firstRowElt, m_pivotperm.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>().data());</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    }</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  }</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;  </div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="comment">// Finalize the column pointers of the sparse matrices R and Q</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  m_Q.finalize();</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  m_Q.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ad9b10bd4b327e69bac9a95c885a633f3">makeCompressed</a>();</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;  m_R.finalize();</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  m_R.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ad9b10bd4b327e69bac9a95c885a633f3">makeCompressed</a>();</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  m_isQSorted = <span class="keyword">false</span>;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  </div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  m_nonzeropivots = nonzeroCol;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  </div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  <span class="keywordflow">if</span>(nonzeroCol&lt;n)</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;  {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="comment">// Permute the triangular factor to put the &#39;dead&#39; columns to the end</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    MatrixType tempR(m_R);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    m_R = tempR * m_pivotperm;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    </div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="comment">// Update the column permutation</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    m_outputPerm_c = m_outputPerm_c * m_pivotperm;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  }</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  </div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  m_isInitialized = <span class="keyword">true</span>; </div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;  m_factorizationIsok = <span class="keyword">true</span>;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Success</a>;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;}</div><div class="ttc" id="class_eigen_1_1_sparse_matrix_html_ad9b10bd4b327e69bac9a95c885a633f3"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#ad9b10bd4b327e69bac9a95c885a633f3">Eigen::SparseMatrix::makeCompressed</a></div><div class="ttdeci">void makeCompressed()</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00449">SparseMatrix.h:449</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a55a8c8bc53a972811bda8909b2d17443"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a55a8c8bc53a972811bda8909b2d17443">Eigen::SparseMatrix::uncompress</a></div><div class="ttdeci">void uncompress()</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00478">SparseMatrix.h:478</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_base_html_ad49129f2301063ce046ae071c82610d5"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix_base.html#ad49129f2301063ce046ae071c82610d5">Eigen::SparseMatrixBase::col</a></div><div class="ttdeci">ColXpr col(Index i)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_base_8h_source.html#l00709">SparseMatrixBase.h:709</a></div></div>
<div class="ttc" id="group__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea580b2a3cafe585691e789f768fb729bf"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea580b2a3cafe585691e789f768fb729bf">Eigen::InvalidInput</a></div><div class="ttdef"><b>Definition:</b> <a href="_constants_8h_source.html#l00383">Constants.h:383</a></div></div>
<div class="ttc" id="group__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Eigen::Success</a></div><div class="ttdef"><b>Definition:</b> <a href="_constants_8h_source.html#l00376">Constants.h:376</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_ac637509429ed2e8aa3b846b9e02da8e4"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">Eigen::PermutationBase::size</a></div><div class="ttdeci">Index size() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00114">PermutationMatrix.h:114</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_ac76a65c37b2bc5043b17b9f8b6dab580"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#ac76a65c37b2bc5043b17b9f8b6dab580">Eigen::SparseMatrix::innerNonZeroPtr</a></div><div class="ttdeci">const Index * innerNonZeroPtr() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00158">SparseMatrix.h:158</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_matrix_html_a523ff8c60307b5e9f27526599185acd3"><div class="ttname"><a href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">Eigen::PermutationMatrix::indices</a></div><div class="ttdeci">const IndicesType &amp; indices() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00358">PermutationMatrix.h:358</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_a6805bb75fd7966ea71895c24ff196444"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#a6805bb75fd7966ea71895c24ff196444">Eigen::PermutationBase::setIdentity</a></div><div class="ttdeci">void setIdentity()</div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00148">PermutationMatrix.h:148</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a6f4be33f4f94c86f003fda0c5c7911b2"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">Eigen::SparseMatrix::outerIndexPtr</a></div><div class="ttdeci">const Index * outerIndexPtr() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00149">SparseMatrix.h:149</a></div></div>
<div class="ttc" id="namespace_eigen_1_1internal_html_a22b184331e5fb270a37d1305e95cb064"><div class="ttname"><a href="namespace_eigen_1_1internal.html#a22b184331e5fb270a37d1305e95cb064">Eigen::internal::coletree</a></div><div class="ttdeci">int coletree(const MatrixType &amp;mat, IndexVector &amp;parent, IndexVector &amp;firstRowElt, typename MatrixType::Index *perm=0)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_col_etree_8h_source.html#l00061">SparseColEtree.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c31869fcfc19707c882347a9c77fa3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether previous computation was successful. </p>
<dl class="section return"><dt>Returns</dt><dd><code>Success</code> if computation was succesful, <code>NumericalIssue</code> if the <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization reports a numerical problem <code>InvalidInput</code> if the input matrix is invalid</dd></dl>
<dl class="section see"><dt>See also</dt><dd>iparm() </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00214">214</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    {</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      eigen_assert(m_isInitialized &amp;&amp; <span class="stringliteral">&quot;Decomposition is not initialized.&quot;</span>);</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="keywordflow">return</span> m_info;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ada1014cfe3e3ecbc6e6496e2c3962933"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::lastErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string describing the type of error. This method is provided to ease debugging, not to handle errors. </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00147">147</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;{ <span class="keywordflow">return</span> m_lastError; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7bfbc1f00bd3ef3e5eece6eb4aea237d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_sparse_q_r_matrix_q_return_type.html">SparseQRMatrixQReturnType</a>&lt;<a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a>&gt; <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::matrixQ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix Q as products of sparse Householder reflectors. The common usage of this function is to apply it to a dense matrix or vector <div class="fragment"><div class="line">VectorXd B1, B2;</div><div class="line"><span class="comment">// Initialize B1</span></div><div class="line">B2 = <a class="code" href="class_eigen_1_1_sparse_q_r.html#a7bfbc1f00bd3ef3e5eece6eb4aea237d">matrixQ</a>() * B1;</div></div><!-- fragment --></dd></dl>
<p>To get a plain <a class="el" href="class_eigen_1_1_sparse_matrix.html" title="A versatible sparse matrix representation. ">SparseMatrix</a> representation of Q: </p><div class="fragment"><div class="line">SparseMatrix&lt;double&gt; Q;</div><div class="line">Q = SparseQR&lt;SparseMatrix&lt;double&gt; &gt;(A).<a class="code" href="class_eigen_1_1_sparse_q_r.html#a7bfbc1f00bd3ef3e5eece6eb4aea237d">matrixQ</a>();</div></div><!-- fragment --><p> Internally, this call simply performs a sparse product between the matrix Q and a sparse identity matrix. However, due to the fact that the sparse reflectors are stored unsorted, two transpositions are needed to sort them before performing the product. </p>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00132">132</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    { <span class="keywordflow">return</span> SparseQRMatrixQReturnType&lt;SparseQR&gt;(*this); }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac085ba4cbf32ff1598e437d939f86556"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_sparse_matrix.html">QRMatrixType</a>&amp; <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::matrixR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const reference to the <b>sparse</b> upper triangular matrix R of the <a class="el" href="class_eigen_1_1_q_r.html">QR</a> factorization. </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00102">102</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;{ <span class="keywordflow">return</span> m_R; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afe9c12de1c84aee249433d7764caee63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non linearly dependent columns as determined by the pivoting threshold.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_q_r.html#adb7bfa65f99e3ef91ed58ea663a850a1">setPivotThreshold()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00108">108</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    {</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      eigen_assert(m_isInitialized &amp;&amp; <span class="stringliteral">&quot;The factorization should be called first, use compute()&quot;</span>);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      <span class="keywordflow">return</span> m_nonzeropivots; </div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfb9120e3f108695e79a72994cb8a914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows of the represented matrix. </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00094">94</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;{ <span class="keywordflow">return</span> m_pmat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ac85d6120f30c302c0a3164068c452dec">rows</a>(); }</div><div class="ttc" id="class_eigen_1_1_sparse_matrix_html_ac85d6120f30c302c0a3164068c452dec"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#ac85d6120f30c302c0a3164068c452dec">Eigen::SparseMatrix::rows</a></div><div class="ttdeci">Index rows() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00119">SparseMatrix.h:119</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adb7bfa65f99e3ef91ed58ea663a850a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::setPivotThreshold </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the threshold that is used to determine linearly dependent columns during the factorization.</p>
<p>In practice, if during the factorization the norm of the column that has to be eliminated is below this threshold, then the entire column is treated as zero, and it is moved at the end. </p>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00181">181</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    {</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;      m_useDefaultThreshold = <span class="keyword">false</span>;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      m_threshold = threshold;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6d8b8fa7268cd8ba8af135ce42684c05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<div class="memtemplate">
template&lt;typename Rhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_eigen_1_1internal_1_1solve__retval.html">internal::solve_retval</a>&lt;<a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a>, Rhs&gt; <a class="el" href="class_eigen_1_1_sparse_q_r.html">Eigen::SparseQR</a>&lt; _MatrixType, _OrderingType &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Rhs &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the solution X of <img class="formulaInl" alt="$ A X = B $" src="form_204.png"/> using the current decomposition of A.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>compute() </dd></dl>

<p>Definition at line <a class="el" href="_sparse_q_r_8h_source.html#l00192">192</a> of file <a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      eigen_assert(m_isInitialized &amp;&amp; <span class="stringliteral">&quot;The factorization should be called first, use compute()&quot;</span>);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      eigen_assert(this-&gt;<a class="code" href="class_eigen_1_1_sparse_q_r.html#adfb9120e3f108695e79a72994cb8a914">rows</a>() == B.rows() &amp;&amp; <span class="stringliteral">&quot;SparseQR::solve() : invalid number of rows in the right hand side matrix&quot;</span>);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      <span class="keywordflow">return</span> internal::solve_retval&lt;SparseQR, Rhs&gt;(*<span class="keyword">this</span>, B.derived());</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div><div class="ttc" id="class_eigen_1_1_sparse_q_r_html_adfb9120e3f108695e79a72994cb8a914"><div class="ttname"><a href="class_eigen_1_1_sparse_q_r.html#adfb9120e3f108695e79a72994cb8a914">Eigen::SparseQR::rows</a></div><div class="ttdeci">Index rows() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_q_r_8h_source.html#l00094">SparseQR.h:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Brig/Documents/ShapeWorksStudio/src/Surfworks/Eigen/src/SparseQR/<a class="el" href="_sparse_q_r_8h_source.html">SparseQR.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 15 2016 13:47:59 for Shapeworks Studio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
