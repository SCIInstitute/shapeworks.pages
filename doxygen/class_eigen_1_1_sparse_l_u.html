<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Shapeworks Studio: Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="splash.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shapeworks Studio
   &#160;<span id="projectnumber">2.1</span>
   </div>
   <div id="projectbrief">Shape analysis software suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="https://github.com/SCIInstitute/ShapeWorksStudio"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Eigen</b></li><li class="navelem"><a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_eigen_1_1_sparse_l_u-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse supernodal <a class="el" href="class_eigen_1_1_l_u.html">LU</a> factorization for general matrices.  
 <a href="class_eigen_1_1_sparse_l_u.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_eigen_1_1_sparse_l_u__inherit__graph.png" border="0" usemap="#_eigen_1_1_sparse_l_u_3_01___matrix_type_00_01___ordering_type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_eigen_1_1_sparse_l_u_3_01___matrix_type_00_01___ordering_type_01_4_inherit__map" id="_eigen_1_1_sparse_l_u_3_01___matrix_type_00_01___ordering_type_01_4_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_eigen_1_1_sparse_l_u__coll__graph.png" border="0" usemap="#_eigen_1_1_sparse_l_u_3_01___matrix_type_00_01___ordering_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_eigen_1_1_sparse_l_u_3_01___matrix_type_00_01___ordering_type_01_4_coll__map" id="_eigen_1_1_sparse_l_u_3_01___matrix_type_00_01___ordering_type_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afde6955eb546fc127e96ad2c1fc087e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afde6955eb546fc127e96ad2c1fc087e2"></a>
typedef _MatrixType&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:afde6955eb546fc127e96ad2c1fc087e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e51e8f3e71a9fec516aaecef7b778"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e2e51e8f3e71a9fec516aaecef7b778"></a>
typedef _OrderingType&#160;</td><td class="memItemRight" valign="bottom"><b>OrderingType</b></td></tr>
<tr class="separator:a2e2e51e8f3e71a9fec516aaecef7b778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a0173a3e2ff548bc643c7c4f6c149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a105a0173a3e2ff548bc643c7c4f6c149"></a>
typedef MatrixType::Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b></td></tr>
<tr class="separator:a105a0173a3e2ff548bc643c7c4f6c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569faba9d46aee2e8ffcf396bf09089"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7569faba9d46aee2e8ffcf396bf09089"></a>
typedef MatrixType::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:a7569faba9d46aee2e8ffcf396bf09089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac042d906593e335772139211bcf83a2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac042d906593e335772139211bcf83a2f"></a>
typedef MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b></td></tr>
<tr class="separator:ac042d906593e335772139211bcf83a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8615f8274a1c9cc521838ce9766306f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8615f8274a1c9cc521838ce9766306f"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, ColMajor, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NCMatrix</b></td></tr>
<tr class="separator:ab8615f8274a1c9cc521838ce9766306f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301d50d699de0e42ac70785eb43263b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a301d50d699de0e42ac70785eb43263b2"></a>
typedef <a class="el" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html">internal::MappedSuperNodalMatrix</a>&lt; Scalar, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SCMatrix</b></td></tr>
<tr class="separator:a301d50d699de0e42ac70785eb43263b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67621b3c8526fc5606a7a708427a959"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac67621b3c8526fc5606a7a708427a959"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:ac67621b3c8526fc5606a7a708427a959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5168ddb2bb9cd453fa11aa15ecccad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5168ddb2bb9cd453fa11aa15ecccad"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Index, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a7a5168ddb2bb9cd453fa11aa15ecccad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f44aa576983e193a8378142bf65eb22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f44aa576983e193a8378142bf65eb22"></a>
typedef <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationMatrix</a>&lt; Dynamic, Dynamic, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PermutationType</b></td></tr>
<tr class="separator:a9f44aa576983e193a8378142bf65eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d2b718164bd44b596a354506048f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6d2b718164bd44b596a354506048f3"></a>
typedef <a class="el" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html">internal::SparseLUImpl</a>&lt; Scalar, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="separator:afa6d2b718164bd44b596a354506048f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html">Eigen::internal::SparseLUImpl&lt; _MatrixType::Scalar, _MatrixType::Index &gt;</a></td></tr>
<tr class="memitem:ad2d25473615285eee61f8589b6ce67e1 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d25473615285eee61f8589b6ce67e1"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; _MatrixType::Scalar, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:ad2d25473615285eee61f8589b6ce67e1 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324c3b4f8c848d4d270cd7b5159a3d70 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a324c3b4f8c848d4d270cd7b5159a3d70"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; _MatrixType::Index, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a324c3b4f8c848d4d270cd7b5159a3d70 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb84aa3fbc3bd0ece860288c6741907 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecb84aa3fbc3bd0ece860288c6741907"></a>
typedef ScalarVector::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:aecb84aa3fbc3bd0ece860288c6741907 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d9e7ba751fbee938e6a612af7c888f inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d9e7ba751fbee938e6a612af7c888f"></a>
typedef <a class="el" href="class_eigen_1_1_ref.html">Ref</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; _MatrixType::Scalar, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockScalarVector</b></td></tr>
<tr class="separator:a90d9e7ba751fbee938e6a612af7c888f inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c9f460f2f75fc43fed1f73d597051f inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c9f460f2f75fc43fed1f73d597051f"></a>
typedef <a class="el" href="class_eigen_1_1_ref.html">Ref</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; _MatrixType::Index, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockIndexVector</b></td></tr>
<tr class="separator:af8c9f460f2f75fc43fed1f73d597051f inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eee895cb8f69c5c8d435a9f01efb1c inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6eee895cb8f69c5c8d435a9f01efb1c"></a>
typedef <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">LU_GlobalLU_t</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a>, <a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalLU_t</b></td></tr>
<tr class="separator:ac6eee895cb8f69c5c8d435a9f01efb1c inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95939b10d8743a788d340d41527eb261 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95939b10d8743a788d340d41527eb261"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; _MatrixType::Scalar, ColMajor, _MatrixType::Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:a95939b10d8743a788d340d41527eb261 inherit pub_types_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac1678e57af46b42561cea4f149861164"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1678e57af46b42561cea4f149861164"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseLU</b> (const MatrixType &amp;<a class="el" href="classmatrix.html">matrix</a>)</td></tr>
<tr class="separator:ac1678e57af46b42561cea4f149861164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907ff958c4f4855145091d2686f3a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#aa907ff958c4f4855145091d2686f3a8a">analyzePattern</a> (const MatrixType &amp;<a class="el" href="classmatrix.html">matrix</a>)</td></tr>
<tr class="separator:aa907ff958c4f4855145091d2686f3a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39858b0e72f2659d596364e252b34cbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a39858b0e72f2659d596364e252b34cbc">factorize</a> (const MatrixType &amp;<a class="el" href="classmatrix.html">matrix</a>)</td></tr>
<tr class="separator:a39858b0e72f2659d596364e252b34cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4841f300341aab4999881ce7f6e38b40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4841f300341aab4999881ce7f6e38b40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>simplicialfactorize</b> (const MatrixType &amp;<a class="el" href="classmatrix.html">matrix</a>)</td></tr>
<tr class="separator:a4841f300341aab4999881ce7f6e38b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a8dcb02015ab9be5777d4ba9173266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a96a8dcb02015ab9be5777d4ba9173266">compute</a> (const MatrixType &amp;<a class="el" href="classmatrix.html">matrix</a>)</td></tr>
<tr class="separator:a96a8dcb02015ab9be5777d4ba9173266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e9fc5580e2b5b5042f53cd160e8ecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79e9fc5580e2b5b5042f53cd160e8ecf"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const </td></tr>
<tr class="separator:a79e9fc5580e2b5b5042f53cd160e8ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8534a17cc5b75f4dd41b6eb238abce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8534a17cc5b75f4dd41b6eb238abce5"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>cols</b> () const </td></tr>
<tr class="separator:ab8534a17cc5b75f4dd41b6eb238abce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff3bd506cd78172e5219c707562729f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#afff3bd506cd78172e5219c707562729f">isSymmetric</a> (bool sym)</td></tr>
<tr class="separator:afff3bd506cd78172e5219c707562729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb96e32259c4d8a56ff7106e2aa5a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_sparse_l_u_matrix_l_return_type.html">SparseLUMatrixLReturnType</a>&lt; <a class="el" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html">SCMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a5eb96e32259c4d8a56ff7106e2aa5a78">matrixL</a> () const </td></tr>
<tr class="separator:a5eb96e32259c4d8a56ff7106e2aa5a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa9ef8da7dff41e3f9a0fbe1f466365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_sparse_l_u_matrix_u_return_type.html">SparseLUMatrixUReturnType</a>&lt; <a class="el" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html">SCMatrix</a>, <a class="el" href="class_eigen_1_1_mapped_sparse_matrix.html">MappedSparseMatrix</a>&lt; Scalar, ColMajor, Index &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#aafa9ef8da7dff41e3f9a0fbe1f466365">matrixU</a> () const </td></tr>
<tr class="separator:aafa9ef8da7dff41e3f9a0fbe1f466365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2316b6a3f3bc779884f2450e798538b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#ae2316b6a3f3bc779884f2450e798538b">rowsPermutation</a> () const </td></tr>
<tr class="separator:ae2316b6a3f3bc779884f2450e798538b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653db904a2a95add81ef8db1a13c0a0c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a653db904a2a95add81ef8db1a13c0a0c">colsPermutation</a> () const </td></tr>
<tr class="separator:a653db904a2a95add81ef8db1a13c0a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c726c9ebb71a60b529fe47d942ad57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a94c726c9ebb71a60b529fe47d942ad57">setPivotThreshold</a> (const RealScalar &amp;thresh)</td></tr>
<tr class="separator:a94c726c9ebb71a60b529fe47d942ad57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c51ef69c29cb7e8e621ebc70dc4fef"><td class="memTemplParams" colspan="2">template&lt;typename Rhs &gt; </td></tr>
<tr class="memitem:a64c51ef69c29cb7e8e621ebc70dc4fef"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_eigen_1_1internal_1_1solve__retval.html">internal::solve_retval</a>&lt; <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>, Rhs &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a64c51ef69c29cb7e8e621ebc70dc4fef">solve</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Rhs &gt; &amp;B) const </td></tr>
<tr class="separator:a64c51ef69c29cb7e8e621ebc70dc4fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cadeb083cf0ccaf093e9953e2207169"><td class="memTemplParams" colspan="2">template&lt;typename Rhs &gt; </td></tr>
<tr class="memitem:a0cadeb083cf0ccaf093e9953e2207169"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_eigen_1_1internal_1_1sparse__solve__retval.html">internal::sparse_solve_retval</a>&lt; <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>, Rhs &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a0cadeb083cf0ccaf093e9953e2207169">solve</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Rhs &gt; &amp;B) const </td></tr>
<tr class="separator:a0cadeb083cf0ccaf093e9953e2207169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465989d7a0565f9bbe02836dd6586b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a465989d7a0565f9bbe02836dd6586b92">info</a> () const </td></tr>
<tr class="memdesc:a465989d7a0565f9bbe02836dd6586b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether previous computation was successful.  <a href="#a465989d7a0565f9bbe02836dd6586b92">More...</a><br /></td></tr>
<tr class="separator:a465989d7a0565f9bbe02836dd6586b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1866df3ffb444b0797a5cd1cb87e000f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a1866df3ffb444b0797a5cd1cb87e000f">lastErrorMessage</a> () const </td></tr>
<tr class="separator:a1866df3ffb444b0797a5cd1cb87e000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46d1c2697bfeca1866bc1fb8561ab82"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa46d1c2697bfeca1866bc1fb8561ab82"></a>
template&lt;typename Rhs , typename Dest &gt; </td></tr>
<tr class="memitem:aa46d1c2697bfeca1866bc1fb8561ab82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_solve</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Rhs &gt; &amp;B, <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Dest &gt; &amp;_X) const </td></tr>
<tr class="separator:aa46d1c2697bfeca1866bc1fb8561ab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa89424239fb169d408f08252426d0"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a06fa89424239fb169d408f08252426d0">absDeterminant</a> ()</td></tr>
<tr class="separator:a06fa89424239fb169d408f08252426d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b4e23dc8beb49dd4bdae2ba3407564"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a78b4e23dc8beb49dd4bdae2ba3407564">logAbsDeterminant</a> () const </td></tr>
<tr class="separator:a78b4e23dc8beb49dd4bdae2ba3407564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6651143e3b18fa90cfb3808b6fd23c4e"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html#a6651143e3b18fa90cfb3808b6fd23c4e">signDeterminant</a> ()</td></tr>
<tr class="separator:a6651143e3b18fa90cfb3808b6fd23c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a38372b5d6f461e3a92fc7c8fb621b730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38372b5d6f461e3a92fc7c8fb621b730"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initperfvalues</b> ()</td></tr>
<tr class="separator:a38372b5d6f461e3a92fc7c8fb621b730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html">Eigen::internal::SparseLUImpl&lt; _MatrixType::Scalar, _MatrixType::Index &gt;</a></td></tr>
<tr class="memitem:ad979a6954777def3d05ba2c0cfb596fd inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>expand</b> (VectorType &amp;vec, _MatrixType::Index &amp;length, _MatrixType::Index nbElts, _MatrixType::Index keep_prev, _MatrixType::Index &amp;num_expansions)</td></tr>
<tr class="separator:ad979a6954777def3d05ba2c0cfb596fd inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9945782ef14205cc9fe5d0723394ab9 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>memInit</b> (_MatrixType::Index m, _MatrixType::Index n, _MatrixType::Index annz, _MatrixType::Index lwork, _MatrixType::Index fillratio, _MatrixType::Index panel_size, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:af9945782ef14205cc9fe5d0723394ab9 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate various working space for the numerical factorization phase.  <a href="#af9945782ef14205cc9fe5d0723394ab9">More...</a><br /></td></tr>
<tr class="separator:af9945782ef14205cc9fe5d0723394ab9 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a50133ee1ca25c7a23f0099dcaab8 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>memXpand</b> (VectorType &amp;vec, _MatrixType::Index &amp;maxlen, _MatrixType::Index nbElts, MemType memtype, _MatrixType::Index &amp;num_expansions)</td></tr>
<tr class="memdesc:a8c1a50133ee1ca25c7a23f0099dcaab8 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the existing storage.  <a href="#a8c1a50133ee1ca25c7a23f0099dcaab8">More...</a><br /></td></tr>
<tr class="separator:a8c1a50133ee1ca25c7a23f0099dcaab8 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0840b6b32610849ace18f86af6ada25 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>heap_relax_snode</b> (const _MatrixType::Index n, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;et, const _MatrixType::Index relax_columns, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;descendants, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;relax_end)</td></tr>
<tr class="memdesc:ad0840b6b32610849ace18f86af6ada25 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the initial relaxed supernodes.  <a href="#ad0840b6b32610849ace18f86af6ada25">More...</a><br /></td></tr>
<tr class="separator:ad0840b6b32610849ace18f86af6ada25 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e432734e3c35cc52ca11e61942a8d4b inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>relax_snode</b> (const _MatrixType::Index n, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;et, const _MatrixType::Index relax_columns, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;descendants, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;relax_end)</td></tr>
<tr class="memdesc:a4e432734e3c35cc52ca11e61942a8d4b inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the initial relaxed supernodes.  <a href="#a4e432734e3c35cc52ca11e61942a8d4b">More...</a><br /></td></tr>
<tr class="separator:a4e432734e3c35cc52ca11e61942a8d4b inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bb06478c3008ff1060dcc5d0091ef inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643bb06478c3008ff1060dcc5d0091ef"></a>
_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>snode_dfs</b> (const _MatrixType::Index jcol, const _MatrixType::Index kcol, const <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &amp;mat, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;marker, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="separator:a643bb06478c3008ff1060dcc5d0091ef inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63a3bccd7f153cc5555a3e9b8677706 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad63a3bccd7f153cc5555a3e9b8677706"></a>
_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>snode_bmod</b> (const _MatrixType::Index jcol, const _MatrixType::Index fsupc, <a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="separator:ad63a3bccd7f153cc5555a3e9b8677706 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fafc0d103de24f5d9da43b6168179 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>pivotL</b> (const _MatrixType::Index jcol, const RealScalar &amp;diagpivotthresh, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;iperm_c, _MatrixType::Index &amp;pivrow, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a691fafc0d103de24f5d9da43b6168179 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the numerical pivotin on the current column of L, and the CDIV operation.  <a href="#a691fafc0d103de24f5d9da43b6168179">More...</a><br /></td></tr>
<tr class="separator:a691fafc0d103de24f5d9da43b6168179 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7839502cf8aeb815e79d35629776d48 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7839502cf8aeb815e79d35629776d48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dfs_kernel</b> (const _MatrixType::Index jj, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, _MatrixType::Index &amp;nseg, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;panel_lsub, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="class_eigen_1_1_ref.html">Ref</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &gt; repfnz_col, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="class_eigen_1_1_ref.html">Ref</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &gt; marker, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;parent, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu, _MatrixType::Index &amp;nextl_col, _MatrixType::Index krow, Traits &amp;<a class="el" href="struct_eigen_1_1internal_1_1traits.html">traits</a>)</td></tr>
<tr class="separator:ac7839502cf8aeb815e79d35629776d48 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeee6ff7667d743c96986081f62d751 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>panel_dfs</b> (const _MatrixType::Index m, const _MatrixType::Index w, const _MatrixType::Index jcol, <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &amp;A, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, _MatrixType::Index &amp;nseg, <a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;panel_lsub, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;repfnz, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;marker, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;parent, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:aaaeee6ff7667d743c96986081f62d751 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symbolic factorization on a panel of columns [jcol, jcol+w)  <a href="#aaaeee6ff7667d743c96986081f62d751">More...</a><br /></td></tr>
<tr class="separator:aaaeee6ff7667d743c96986081f62d751 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8fad25e9562c5231e81fe8ed61db16 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>panel_bmod</b> (const _MatrixType::Index m, const _MatrixType::Index w, const _MatrixType::Index jcol, const _MatrixType::Index nseg, <a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a> &amp;tempv, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;repfnz, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a7e8fad25e9562c5231e81fe8ed61db16 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-panel) in topological order.  <a href="#a7e8fad25e9562c5231e81fe8ed61db16">More...</a><br /></td></tr>
<tr class="separator:a7e8fad25e9562c5231e81fe8ed61db16 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08e94104581b16697bd7b5828cb8507 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>column_dfs</b> (const _MatrixType::Index m, const _MatrixType::Index jcol, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, _MatrixType::Index maxsuper, _MatrixType::Index &amp;nseg, <a class="el" href="class_eigen_1_1_ref.html">BlockIndexVector</a> lsub_col, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="class_eigen_1_1_ref.html">BlockIndexVector</a> repfnz, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;marker, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;parent, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ab08e94104581b16697bd7b5828cb8507 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symbolic factorization on column jcol and decide the supernode boundary.  <a href="#ab08e94104581b16697bd7b5828cb8507">More...</a><br /></td></tr>
<tr class="separator:ab08e94104581b16697bd7b5828cb8507 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979f09ffe0983fdff318e3dbf2eef68 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>column_bmod</b> (const _MatrixType::Index jcol, const _MatrixType::Index nseg, <a class="el" href="class_eigen_1_1_ref.html">BlockScalarVector</a> dense, <a class="el" href="class_eigen_1_1_matrix.html">ScalarVector</a> &amp;tempv, <a class="el" href="class_eigen_1_1_ref.html">BlockIndexVector</a> segrep, <a class="el" href="class_eigen_1_1_ref.html">BlockIndexVector</a> repfnz, _MatrixType::Index fpanelc, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a0979f09ffe0983fdff318e3dbf2eef68 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-col) in topological order.  <a href="#a0979f09ffe0983fdff318e3dbf2eef68">More...</a><br /></td></tr>
<tr class="separator:a0979f09ffe0983fdff318e3dbf2eef68 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb30e5fc6e55e741fb091cc131a0835 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">_MatrixType::Index&#160;</td><td class="memItemRight" valign="bottom"><b>copy_to_ucol</b> (const _MatrixType::Index jcol, const _MatrixType::Index nseg, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="class_eigen_1_1_ref.html">BlockIndexVector</a> repfnz, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="class_eigen_1_1_ref.html">BlockScalarVector</a> dense, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a6cb30e5fc6e55e741fb091cc131a0835 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-col) in topological order.  <a href="#a6cb30e5fc6e55e741fb091cc131a0835">More...</a><br /></td></tr>
<tr class="separator:a6cb30e5fc6e55e741fb091cc131a0835 inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e3d1176edfa0365f5de8928739bfd inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>pruneL</b> (const _MatrixType::Index jcol, const <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, const _MatrixType::Index pivrow, const _MatrixType::Index nseg, const <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="class_eigen_1_1_ref.html">BlockIndexVector</a> repfnz, <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:aa17e3d1176edfa0365f5de8928739bfd inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prunes the L-structure.  <a href="#aa17e3d1176edfa0365f5de8928739bfd">More...</a><br /></td></tr>
<tr class="separator:aa17e3d1176edfa0365f5de8928739bfd inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056d27d2f8d025109c8176f319a7821e inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a056d27d2f8d025109c8176f319a7821e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>countnz</b> (const _MatrixType::Index n, _MatrixType::Index &amp;nnzL, _MatrixType::Index &amp;nnzU, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a056d27d2f8d025109c8176f319a7821e inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Nonzero elements in the factors. <br /></td></tr>
<tr class="separator:a056d27d2f8d025109c8176f319a7821e inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a577417a1cfe48f1e051651dc7e015b inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupL</b> (const _MatrixType::Index n, const <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a1a577417a1cfe48f1e051651dc7e015b inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts.  <a href="#a1a577417a1cfe48f1e051651dc7e015b">More...</a><br /></td></tr>
<tr class="separator:a1a577417a1cfe48f1e051651dc7e015b inherit pro_methods_class_eigen_1_1internal_1_1_sparse_l_u_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b8c30dd64606c6396b04c052bc88a80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b8c30dd64606c6396b04c052bc88a80"></a>
<a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_info</b></td></tr>
<tr class="separator:a3b8c30dd64606c6396b04c052bc88a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846e2e3d2c57b904f8b60b2c57033188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a846e2e3d2c57b904f8b60b2c57033188"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isInitialized</b></td></tr>
<tr class="separator:a846e2e3d2c57b904f8b60b2c57033188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9049c98a8f53316c2ed9daa49c7db5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f9049c98a8f53316c2ed9daa49c7db5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_factorizationIsOk</b></td></tr>
<tr class="separator:a0f9049c98a8f53316c2ed9daa49c7db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a135b7a2548570384702a3d016043f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a135b7a2548570384702a3d016043f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_analysisIsOk</b></td></tr>
<tr class="separator:a9a135b7a2548570384702a3d016043f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc89f4bf70115b56c4eab39d7f39a88d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc89f4bf70115b56c4eab39d7f39a88d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_lastError</b></td></tr>
<tr class="separator:abc89f4bf70115b56c4eab39d7f39a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489466ddda50b9200444031544d317f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0489466ddda50b9200444031544d317f"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">NCMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_mat</b></td></tr>
<tr class="separator:a0489466ddda50b9200444031544d317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a260e5b5860fa9e2a995d89f71234f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33a260e5b5860fa9e2a995d89f71234f"></a>
<a class="el" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html">SCMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_Lstore</b></td></tr>
<tr class="separator:a33a260e5b5860fa9e2a995d89f71234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb58a4438170621247fc3cf4000ed708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb58a4438170621247fc3cf4000ed708"></a>
<a class="el" href="class_eigen_1_1_mapped_sparse_matrix.html">MappedSparseMatrix</a>&lt; Scalar, ColMajor, Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_Ustore</b></td></tr>
<tr class="separator:adb58a4438170621247fc3cf4000ed708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17880d2a5075b0ad2be69e9a98b18d95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17880d2a5075b0ad2be69e9a98b18d95"></a>
<a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_perm_c</b></td></tr>
<tr class="separator:a17880d2a5075b0ad2be69e9a98b18d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0cd35485f50f819b65856f6989264a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0cd35485f50f819b65856f6989264a"></a>
<a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_perm_r</b></td></tr>
<tr class="separator:a1d0cd35485f50f819b65856f6989264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bdda3c848baf65f906ad810bb67667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93bdda3c848baf65f906ad810bb67667"></a>
<a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_etree</b></td></tr>
<tr class="separator:a93bdda3c848baf65f906ad810bb67667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6707db24747af79024d9dd86cbe92d32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6707db24747af79024d9dd86cbe92d32"></a>
<a class="el" href="struct_eigen_1_1internal_1_1_l_u___global_l_u__t.html">Base::GlobalLU_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_glu</b></td></tr>
<tr class="separator:a6707db24747af79024d9dd86cbe92d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21c4d4a3716038665e7525df123da9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb21c4d4a3716038665e7525df123da9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_symmetricmode</b></td></tr>
<tr class="separator:abb21c4d4a3716038665e7525df123da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293dc267a66ca04318c0f2b2ee5f6905"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a293dc267a66ca04318c0f2b2ee5f6905"></a>
<a class="el" href="struct_eigen_1_1internal_1_1perfvalues.html">internal::perfvalues</a>&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_perfv</b></td></tr>
<tr class="separator:a293dc267a66ca04318c0f2b2ee5f6905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead99552b5213cee1fada904159c289a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aead99552b5213cee1fada904159c289a"></a>
RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>m_diagpivotthresh</b></td></tr>
<tr class="separator:aead99552b5213cee1fada904159c289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe45ce540c3f7f56b01a97eaaf35825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fe45ce540c3f7f56b01a97eaaf35825"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_nnzL</b></td></tr>
<tr class="separator:a4fe45ce540c3f7f56b01a97eaaf35825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8298823646bfa9b71d18a03cb83c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60d8298823646bfa9b71d18a03cb83c2"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_nnzU</b></td></tr>
<tr class="separator:a60d8298823646bfa9b71d18a03cb83c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd9bd6741f16a8c7a616c7e11bbe05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cfd9bd6741f16a8c7a616c7e11bbe05"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_detPermR</b></td></tr>
<tr class="separator:a7cfd9bd6741f16a8c7a616c7e11bbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _MatrixType, typename _OrderingType&gt;<br />
class Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt;</h3>

<p>Sparse supernodal <a class="el" href="class_eigen_1_1_l_u.html">LU</a> factorization for general matrices. </p>
<p>This class implements the supernodal <a class="el" href="class_eigen_1_1_l_u.html">LU</a> factorization for general matrices. It uses the main techniques from the sequential <a class="el" href="class_eigen_1_1_super_l_u.html" title="A sparse direct LU factorization and solver based on the SuperLU library. ">SuperLU</a> package (<a href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/">http://crd-legacy.lbl.gov/~xiaoye/SuperLU/</a>). It handles transparently real and complex arithmetics with single and double precision, depending on the scalar type of your input matrix. The code has been optimized to provide BLAS-3 operations during supernode-panel updates. It benefits directly from the built-in high-performant Eigen BLAS routines. Moreover, when the size of a supernode is very small, the BLAS calls are avoided to enable a better optimization from the compiler. For best performance, you should compile it with NDEBUG flag to avoid the numerous bounds checking on vectors.</p>
<p>An important parameter of this class is the ordering method. It is used to reorder the columns (and eventually the rows) of the matrix to reduce the number of new elements that are created during numerical factorization. The cheapest method available is COLAMD. See <a class="el" href="">the OrderingMethods module </a> for the list of built-in and external ordering methods.</p>
<p>Simple example with key steps </p><div class="fragment"><div class="line">VectorXd x(n), b(n);</div><div class="line">SparseMatrix&lt;double, ColMajor&gt; A;</div><div class="line">SparseLU&lt;SparseMatrix&lt;scalar, ColMajor&gt;, COLAMDOrdering&lt;Index&gt; &gt;   solver;</div><div class="line"><span class="comment">// fill A and b;</span></div><div class="line"><span class="comment">// Compute the ordering permutation vector from the structural pattern of A</span></div><div class="line">solver.analyzePattern(A); </div><div class="line"><span class="comment">// Compute the numerical factorization </span></div><div class="line">solver.factorize(A); </div><div class="line"><span class="comment">//Use the factors to solve the linear system </span></div><div class="line">x = solver.solve(b); </div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The input matrix A should be in a <b>compressed</b> and <b>column-major</b> form. Otherwise an expensive copy will be made. You can call the inexpensive makeCompressed() to get a compressed matrix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the initial <a class="el" href="class_eigen_1_1_super_l_u.html" title="A sparse direct LU factorization and solver based on the SuperLU library. ">SuperLU</a> implementation, there is no step to equilibrate the matrix. For badly scaled matrices, this step can be useful to reduce the pivoting during factorization. If this is the case for your matrices, you can try the basic scaling method at "unsupported/Eigen/src/IterativeSolvers/Scaling.h"</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_MatrixType</td><td>The type of the sparse matrix. It must be a column-major SparseMatrix&lt;&gt; </td></tr>
    <tr><td class="paramname">_OrderingType</td><td>The ordering method to use, either AMD, COLAMD or METIS. Default is COLMAD</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>TutorialSparseDirectSolvers </dd>
<dd>
OrderingMethods_Module </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00017">17</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a06fa89424239fb169d408f08252426d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::absDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the absolute value of the determinant of the matrix of which *this is the <a class="el" href="class_eigen_1_1_q_r.html">QR</a> decomposition.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>a determinant can be very big or small, so for matrices of large enough dimension, there is a risk of overflow/underflow. One way to work around that is to use <a class="el" href="class_eigen_1_1_sparse_l_u.html#a78b4e23dc8beb49dd4bdae2ba3407564">logAbsDeterminant()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#a78b4e23dc8beb49dd4bdae2ba3407564">logAbsDeterminant()</a>, <a class="el" href="class_eigen_1_1_sparse_l_u.html#a6651143e3b18fa90cfb3808b6fd23c4e">signDeterminant()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00256">256</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      <span class="comment">// Initialize with the determinant of the row matrix</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      Scalar det = Scalar(1.);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      <span class="comment">//Note that the diagonal blocks of U are stored in supernodes,</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      <span class="comment">// which are available in the  L part :)</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      <span class="keywordflow">for</span> (Index j = 0; j &lt; this-&gt;cols(); ++j)</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> SCMatrix::InnerIterator it(m_Lstore, j); it; ++it)</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;          <span class="keywordflow">if</span>(it.row() &lt; j) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;          <span class="keywordflow">if</span>(it.row() == j)</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;          {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            det *= (std::abs)(it.value());</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;          }</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;       }</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;       <span class="keywordflow">return</span> det;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;     }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa907ff958c4f4855145091d2686f3a8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; MatrixType, OrderingType &gt;::analyzePattern </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the column permutation to minimize the fill-in</p>
<ul>
<li>Apply this permutation to the input matrix -</li>
<li>Compute the column elimination tree on the permuted matrix</li>
<li>Postorder the elimination tree and the column permutation </li>
</ul>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00369">369</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;{</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  </div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="comment">//TODO  It is possible as in SuperLU to compute row and columns scaling vectors to equilibrate the matrix mat.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  </div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  OrderingType ord; </div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  ord(mat,m_perm_c);</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  </div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="comment">// Apply the permutation to the column of the input  matrix</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  <span class="comment">//First copy the whole input matrix. </span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  m_mat = mat;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <span class="keywordflow">if</span> (m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">size</a>()) {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a55a8c8bc53a972811bda8909b2d17443">uncompress</a>(); <span class="comment">//NOTE: The effect of this command is only to create the InnerNonzeros pointers. FIXME : This vector is filled but not subsequently used.  </span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="comment">//Then, permute only the column pointers</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keyword">const</span> Index * outerIndexPtr;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="keywordflow">if</span> (mat.isCompressed()) outerIndexPtr = mat.outerIndexPtr();</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;      Index *outerIndexPtr_t = <span class="keyword">new</span> Index[mat.cols()+1];</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;      <span class="keywordflow">for</span>(Index i = 0; i &lt;= mat.cols(); i++) outerIndexPtr_t[i] = m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">outerIndexPtr</a>()[i];</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      outerIndexPtr = outerIndexPtr_t;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    }</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; mat.cols(); i++)</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">outerIndexPtr</a>()[m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(i)] = outerIndexPtr[i];</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ac76a65c37b2bc5043b17b9f8b6dab580">innerNonZeroPtr</a>()[m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(i)] = outerIndexPtr[i+1] - outerIndexPtr[i];</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    }</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="keywordflow">if</span>(!mat.isCompressed()) <span class="keyword">delete</span>[] outerIndexPtr;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  }</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <span class="comment">// Compute the column elimination tree of the permuted matrix </span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  IndexVector firstRowElt;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <a class="code" href="namespace_eigen_1_1internal.html#a22b184331e5fb270a37d1305e95cb064">internal::coletree</a>(m_mat, m_etree,firstRowElt); </div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;     </div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="comment">// In symmetric mode, do not do postorder here</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  <span class="keywordflow">if</span> (!m_symmetricmode) {</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    IndexVector post, iwork; </div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">// Post order etree</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <a class="code" href="namespace_eigen_1_1internal.html#a6afa7df34de3dce07b21194168118456">internal::treePostorder</a>(m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">cols</a>(), m_etree, post); </div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      </div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;   </div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="comment">// Renumber etree in postorder </span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    Index m = m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">cols</a>(); </div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    iwork.resize(m+1);</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; m; ++i) iwork(post(i)) = post(m_etree(i));</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    m_etree = iwork;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    </div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="comment">// Postmultiply A*Pc by post, i.e reorder the matrix according to the postorder of the etree</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    PermutationType post_perm(m); </div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; m; i++) </div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;      post_perm.indices()(i) = post(i); </div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        </div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="comment">// Combine the two permutations : postorder the permutation for future use</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">if</span>(m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">size</a>()) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      m_perm_c = post_perm * m_perm_c;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    </div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  } <span class="comment">// end postordering </span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  </div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  m_analysisIsOk = <span class="keyword">true</span>; </div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;}</div><div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a60e574bcb97bd1d210c4d110529b4c89"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">Eigen::SparseMatrix::cols</a></div><div class="ttdeci">Index cols() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00121">SparseMatrix.h:121</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a55a8c8bc53a972811bda8909b2d17443"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a55a8c8bc53a972811bda8909b2d17443">Eigen::SparseMatrix::uncompress</a></div><div class="ttdeci">void uncompress()</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00478">SparseMatrix.h:478</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_ac637509429ed2e8aa3b846b9e02da8e4"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">Eigen::PermutationBase::size</a></div><div class="ttdeci">Index size() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00114">PermutationMatrix.h:114</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_ac76a65c37b2bc5043b17b9f8b6dab580"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#ac76a65c37b2bc5043b17b9f8b6dab580">Eigen::SparseMatrix::innerNonZeroPtr</a></div><div class="ttdeci">const Index * innerNonZeroPtr() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00158">SparseMatrix.h:158</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_matrix_html_a523ff8c60307b5e9f27526599185acd3"><div class="ttname"><a href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">Eigen::PermutationMatrix::indices</a></div><div class="ttdeci">const IndicesType &amp; indices() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00358">PermutationMatrix.h:358</a></div></div>
<div class="ttc" id="namespace_eigen_1_1internal_html_a6afa7df34de3dce07b21194168118456"><div class="ttname"><a href="namespace_eigen_1_1internal.html#a6afa7df34de3dce07b21194168118456">Eigen::internal::treePostorder</a></div><div class="ttdeci">void treePostorder(Index n, IndexVector &amp;parent, IndexVector &amp;post)</div><div class="ttdoc">Post order a tree. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_col_etree_8h_source.html#l00176">SparseColEtree.h:176</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a6f4be33f4f94c86f003fda0c5c7911b2"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">Eigen::SparseMatrix::outerIndexPtr</a></div><div class="ttdeci">const Index * outerIndexPtr() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00149">SparseMatrix.h:149</a></div></div>
<div class="ttc" id="namespace_eigen_1_1internal_html_a22b184331e5fb270a37d1305e95cb064"><div class="ttname"><a href="namespace_eigen_1_1internal.html#a22b184331e5fb270a37d1305e95cb064">Eigen::internal::coletree</a></div><div class="ttdeci">int coletree(const MatrixType &amp;mat, IndexVector &amp;parent, IndexVector &amp;firstRowElt, typename MatrixType::Index *perm=0)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_col_etree_8h_source.html#l00061">SparseColEtree.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a653db904a2a95add81ef8db1a13c0a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&amp; <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::colsPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the column matrix permutation <img class="formulaInl" alt="$ P_c^T $" src="form_203.png"/> such that <img class="formulaInl" alt="$P_r A P_c^T = L U$" src="form_202.png"/> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#ae2316b6a3f3bc779884f2450e798538b">rowsPermutation()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00161">161</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      <span class="keywordflow">return</span> m_perm_c;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a96a8dcb02015ab9be5777d4ba9173266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the symbolic and numeric factorization of the input sparse matrix. The input matrix should be in column-major storage. </p>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00112">112</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      <span class="comment">// Analyze </span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;      <a class="code" href="class_eigen_1_1_sparse_l_u.html#aa907ff958c4f4855145091d2686f3a8a">analyzePattern</a>(<a class="code" href="classmatrix.html">matrix</a>); </div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="comment">//Factorize</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;      <a class="code" href="class_eigen_1_1_sparse_l_u.html#a39858b0e72f2659d596364e252b34cbc">factorize</a>(<a class="code" href="classmatrix.html">matrix</a>);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    } </div><div class="ttc" id="classmatrix_html"><div class="ttname"><a href="classmatrix.html">matrix</a></div><div class="ttdef"><b>Definition:</b> <a href="math3d_8h_source.html#l00219">math3d.h:219</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_l_u_html_aa907ff958c4f4855145091d2686f3a8a"><div class="ttname"><a href="class_eigen_1_1_sparse_l_u.html#aa907ff958c4f4855145091d2686f3a8a">Eigen::SparseLU::analyzePattern</a></div><div class="ttdeci">void analyzePattern(const MatrixType &amp;matrix)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u_8h_source.html#l00369">SparseLU.h:369</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_l_u_html_a39858b0e72f2659d596364e252b34cbc"><div class="ttname"><a href="class_eigen_1_1_sparse_l_u.html#a39858b0e72f2659d596364e252b34cbc">Eigen::SparseLU::factorize</a></div><div class="ttdeci">void factorize(const MatrixType &amp;matrix)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u_8h_source.html#l00452">SparseLU.h:452</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a39858b0e72f2659d596364e252b34cbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; MatrixType, OrderingType &gt;::factorize </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>Numerical factorization</li>
<li><p class="startli">Interleaved with the symbolic factorization On exit, info is</p>
<p class="startli">= 0: successful factorization</p>
</li>
</ul>
<blockquote class="doxtable">
<p>0: if info = i, and i is </p>
</blockquote>
<pre class="fragment">  &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
     been completed, but the factor U is exactly singular,
     and division by zero will occur if it is used to solve a
     system of equations.

  &gt; A-&gt;ncol: number of bytes allocated when memory allocation
    failure occurred, plus A-&gt;ncol. If lwork = -1, it is
    the estimated amount of space needed, plus A-&gt;ncol.  </pre> 
<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00452">452</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;{</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  <span class="keyword">using</span> internal::emptyIdxLU;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  eigen_assert(m_analysisIsOk &amp;&amp; <span class="stringliteral">&quot;analyzePattern() should be called first&quot;</span>); </div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  eigen_assert((<a class="code" href="classmatrix.html">matrix</a>.rows() == <a class="code" href="classmatrix.html">matrix</a>.cols()) &amp;&amp; <span class="stringliteral">&quot;Only for squared matrices&quot;</span>);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  </div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> IndexVector::Scalar Index; </div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  </div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  </div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  <span class="comment">// Apply the column permutation computed in analyzepattern()</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="comment">//   m_mat = matrix * m_perm_c.inverse(); </span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  m_mat = <a class="code" href="classmatrix.html">matrix</a>;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  <span class="keywordflow">if</span> (m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">size</a>()) </div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a55a8c8bc53a972811bda8909b2d17443">uncompress</a>(); <span class="comment">//NOTE: The effect of this command is only to create the InnerNonzeros pointers.</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="comment">//Then, permute only the column pointers</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="keyword">const</span> Index * outerIndexPtr;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classmatrix.html">matrix</a>.isCompressed()) outerIndexPtr = <a class="code" href="classmatrix.html">matrix</a>.outerIndexPtr();</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    {</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;      Index* outerIndexPtr_t = <span class="keyword">new</span> Index[<a class="code" href="classmatrix.html">matrix</a>.cols()+1];</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;      <span class="keywordflow">for</span>(Index i = 0; i &lt;= <a class="code" href="classmatrix.html">matrix</a>.cols(); i++) outerIndexPtr_t[i] = m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">outerIndexPtr</a>()[i];</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      outerIndexPtr = outerIndexPtr_t;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    }</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; <a class="code" href="classmatrix.html">matrix</a>.cols(); i++)</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    {</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">outerIndexPtr</a>()[m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(i)] = outerIndexPtr[i];</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ac76a65c37b2bc5043b17b9f8b6dab580">innerNonZeroPtr</a>()[m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(i)] = outerIndexPtr[i+1] - outerIndexPtr[i];</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    }</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keywordflow">if</span>(!<a class="code" href="classmatrix.html">matrix</a>.isCompressed()) <span class="keyword">delete</span>[] outerIndexPtr;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  } </div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  <span class="keywordflow">else</span> </div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  { <span class="comment">//FIXME This should not be needed if the empty permutation is handled transparently</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#a0e0fda6e84d69e02432e4770359bb532">resize</a>(<a class="code" href="classmatrix.html">matrix</a>.cols());</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keywordflow">for</span>(Index i = 0; i &lt; <a class="code" href="classmatrix.html">matrix</a>.cols(); ++i) m_perm_c.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>()(i) = i;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;  }</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  </div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  Index m = m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#ac85d6120f30c302c0a3164068c452dec">rows</a>();</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  Index n = m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">cols</a>();</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  Index nnz = m_mat.<a class="code" href="class_eigen_1_1_sparse_matrix.html#a0277ddb3afdbba94b915897ea1aa0323">nonZeros</a>();</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  Index maxpanel = m_perfv.panel_size * m;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <span class="comment">// Allocate working storage common to the factor routines</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;  Index lwork = 0;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  Index <a class="code" href="class_eigen_1_1_sparse_l_u.html#a465989d7a0565f9bbe02836dd6586b92">info</a> = <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#af9945782ef14205cc9fe5d0723394ab9">Base::memInit</a>(m, n, nnz, lwork, m_perfv.fillfactor, m_perfv.panel_size, m_glu); </div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  <span class="keywordflow">if</span> (info) </div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    m_lastError = <span class="stringliteral">&quot;UNABLE TO ALLOCATE WORKING MEMORY\n\n&quot;</span> ;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    m_factorizationIsOk = <span class="keyword">false</span>;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    return ; </div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  }</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  </div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  <span class="comment">// Set up pointers for integer working arrays </span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  IndexVector segrep(m); segrep.setZero();</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;  IndexVector parent(m); parent.setZero();</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  IndexVector xplore(m); xplore.setZero();</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  IndexVector repfnz(maxpanel);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  IndexVector panel_lsub(maxpanel);</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  IndexVector xprune(n); xprune.setZero();</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;  IndexVector marker(m*internal::LUNoMarker); marker.setZero();</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;  </div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  repfnz.setConstant(-1); </div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  panel_lsub.setConstant(-1);</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  </div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;  <span class="comment">// Set up pointers for scalar working arrays </span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  ScalarVector dense; </div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;  dense.<a class="code" href="class_eigen_1_1_plain_object_base.html#ab8b732ae4d45271b2532978ee13210d1">setZero</a>(maxpanel);</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;  ScalarVector tempv; </div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;  tempv.<a class="code" href="class_eigen_1_1_plain_object_base.html#ab8b732ae4d45271b2532978ee13210d1">setZero</a>(internal::LUnumTempV(m, m_perfv.panel_size, m_perfv.maxsuper, <span class="comment">/*m_perfv.rowblk*/</span>m) );</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;  </div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  <span class="comment">// Compute the inverse of perm_c</span></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;  PermutationType iperm_c(m_perm_c.<a class="code" href="class_eigen_1_1_permutation_base.html#acd5b0470479df2b040bfadd6937cb4c9">inverse</a>()); </div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;  </div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  <span class="comment">// Identify initial relaxed snodes</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  IndexVector relax_end(n);</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  <span class="keywordflow">if</span> ( m_symmetricmode == <span class="keyword">true</span> ) </div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#ad0840b6b32610849ace18f86af6ada25">Base::heap_relax_snode</a>(n, m_etree, m_perfv.relax, marker, relax_end);</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a4e432734e3c35cc52ca11e61942a8d4b">Base::relax_snode</a>(n, m_etree, m_perfv.relax, marker, relax_end);</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  </div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  </div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  m_perm_r.<a class="code" href="class_eigen_1_1_permutation_base.html#a0e0fda6e84d69e02432e4770359bb532">resize</a>(m); </div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>().setConstant(-1);</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  marker.setConstant(-1);</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  m_detPermR = 1; <span class="comment">// Record the determinant of the row permutation</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  </div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  m_glu.supno(0) = emptyIdxLU; m_glu.xsup.<a class="code" href="class_eigen_1_1_plain_object_base.html#aae4f6fbe5e26385a638ad5fa96c69260">setConstant</a>(0);</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  m_glu.xsup(0) = m_glu.xlsub(0) = m_glu.xusub(0) = m_glu.xlusup(0) = Index(0);</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  </div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <span class="comment">// Work on one &#39;panel&#39; at a time. A panel is one of the following :</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  <span class="comment">//  (a) a relaxed supernode at the bottom of the etree, or</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  <span class="comment">//  (b) panel_size contiguous columns, &lt;panel_size&gt; defined by the user</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  Index jcol; </div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  IndexVector panel_histo(n);</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;  Index pivrow; <span class="comment">// Pivotal row number in the original row matrix</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  Index nseg1; <span class="comment">// Number of segments in U-column above panel row jcol</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  Index nseg; <span class="comment">// Number of segments in each U-column </span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  Index irep; </div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  Index i, k, jj; </div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="keywordflow">for</span> (jcol = 0; jcol &lt; n; )</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    <span class="comment">// Adjust panel size so that a panel won&#39;t overlap with the next relaxed snode. </span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    Index panel_size = m_perfv.panel_size; <span class="comment">// upper bound on panel width</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keywordflow">for</span> (k = jcol + 1; k &lt; (std::min)(jcol+panel_size, n); k++)</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    {</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;      <span class="keywordflow">if</span> (relax_end(k) != emptyIdxLU) </div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;      {</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        panel_size = k - jcol; </div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="keywordflow">break</span>; </div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;      }</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <span class="keywordflow">if</span> (k == n) </div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      panel_size = n - jcol; </div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;      </div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    <span class="comment">// Symbolic outer factorization on a panel of columns </span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#aaaeee6ff7667d743c96986081f62d751">Base::panel_dfs</a>(m, panel_size, jcol, m_mat, m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>(), nseg1, dense, panel_lsub, segrep, repfnz, xprune, marker, parent, xplore, m_glu); </div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    </div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    <span class="comment">// Numeric sup-panel updates in topological order </span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a7e8fad25e9562c5231e81fe8ed61db16">Base::panel_bmod</a>(m, panel_size, jcol, nseg1, dense, tempv, segrep, repfnz, m_glu); </div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    </div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    <span class="comment">// Sparse LU within the panel, and below the panel diagonal </span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    <span class="keywordflow">for</span> ( jj = jcol; jj&lt; jcol + panel_size; jj++) </div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    {</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;      k = (jj - jcol) * m; <span class="comment">// Column index for w-wide arrays </span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;      </div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;      nseg = nseg1; <span class="comment">// begin after all the panel segments</span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      <span class="comment">//Depth-first-search for the current column</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;      VectorBlock&lt;IndexVector&gt; panel_lsubk(panel_lsub, k, m);</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;      VectorBlock&lt;IndexVector&gt; repfnz_k(repfnz, k, m); </div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      info = <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#ab08e94104581b16697bd7b5828cb8507">Base::column_dfs</a>(m, jj, m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>(), m_perfv.maxsuper, nseg, panel_lsubk, segrep, repfnz_k, xprune, marker, parent, xplore, m_glu); </div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;      <span class="keywordflow">if</span> ( info ) </div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;      {</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        m_lastError =  <span class="stringliteral">&quot;UNABLE TO EXPAND MEMORY IN COLUMN_DFS() &quot;</span>;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordflow">return</span>; </div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;      }</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;      <span class="comment">// Numeric updates to this column </span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;      VectorBlock&lt;ScalarVector&gt; dense_k(dense, k, m); </div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      VectorBlock&lt;IndexVector&gt; segrep_k(segrep, nseg1, m-nseg1); </div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;      info = <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a0979f09ffe0983fdff318e3dbf2eef68">Base::column_bmod</a>(jj, (nseg - nseg1), dense_k, tempv, segrep_k, repfnz_k, jcol, m_glu); </div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;      <span class="keywordflow">if</span> ( info ) </div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;      {</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;        m_lastError = <span class="stringliteral">&quot;UNABLE TO EXPAND MEMORY IN COLUMN_BMOD() &quot;</span>;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;        <span class="keywordflow">return</span>; </div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;      }</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      </div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      <span class="comment">// Copy the U-segments to ucol(*)</span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      info = <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a6cb30e5fc6e55e741fb091cc131a0835">Base::copy_to_ucol</a>(jj, nseg, segrep, repfnz_k ,m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>(), dense_k, m_glu); </div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      <span class="keywordflow">if</span> ( info ) </div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      {</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        m_lastError = <span class="stringliteral">&quot;UNABLE TO EXPAND MEMORY IN COPY_TO_UCOL() &quot;</span>;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="keywordflow">return</span>; </div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      }</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;      </div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;      <span class="comment">// Form the L-segment </span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;      info = <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a691fafc0d103de24f5d9da43b6168179">Base::pivotL</a>(jj, m_diagpivotthresh, m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>(), iperm_c.indices(), pivrow, m_glu);</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;      <span class="keywordflow">if</span> ( info ) </div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;      {</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        m_lastError = <span class="stringliteral">&quot;THE MATRIX IS STRUCTURALLY SINGULAR ... ZERO COLUMN AT &quot;</span>;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        std::ostringstream returnInfo;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        returnInfo &lt;&lt; <a class="code" href="class_eigen_1_1_sparse_l_u.html#a465989d7a0565f9bbe02836dd6586b92">info</a>; </div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;        m_lastError += returnInfo.str();</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        <span class="keywordflow">return</span>; </div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;      }</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      </div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;      <span class="comment">// Update the determinant of the row permutation matrix</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;      <span class="keywordflow">if</span> (pivrow != jj) m_detPermR *= -1;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;      <span class="comment">// Prune columns (0:jj-1) using column jj</span></div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;      <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#aa17e3d1176edfa0365f5de8928739bfd">Base::pruneL</a>(jj, m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>(), pivrow, nseg, segrep, repfnz_k, xprune, m_glu); </div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;      </div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;      <span class="comment">// Reset repfnz for this column </span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;      <span class="keywordflow">for</span> (i = 0; i &lt; nseg; i++)</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      {</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        irep = segrep(i); </div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        repfnz_k(irep) = emptyIdxLU; </div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      }</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    } <span class="comment">// end SparseLU within the panel  </span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    jcol += panel_size;  <span class="comment">// Move to the next panel</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  } <span class="comment">// end for -- end elimination </span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  </div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <span class="comment">// Count the number of nonzeros in factors </span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a056d27d2f8d025109c8176f319a7821e">Base::countnz</a>(n, m_nnzL, m_nnzU, m_glu); </div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;  <span class="comment">// Apply permutation  to the L subscripts </span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <a class="code" href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a1a577417a1cfe48f1e051651dc7e015b">Base::fixupL</a>(n, m_perm_r.<a class="code" href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">indices</a>(), m_glu); </div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  </div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  <span class="comment">// Create supernode matrix L </span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;  m_Lstore.<a class="code" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html#a370002c463c9be228844280f6f441af6">setInfos</a>(m, n, m_glu.lusup, m_glu.xlusup, m_glu.lsub, m_glu.xlsub, m_glu.supno, m_glu.xsup); </div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  <span class="comment">// Create the column major upper sparse matrix  U; </span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  <span class="keyword">new</span> (&amp;m_Ustore) MappedSparseMatrix&lt;Scalar, ColMajor, Index&gt; ( m, n, m_nnzU, m_glu.xusub.<a class="code" href="class_eigen_1_1_plain_object_base.html#a5020fe0b4907becaece0a75271db9bff">data</a>(), m_glu.usub.<a class="code" href="class_eigen_1_1_plain_object_base.html#a5020fe0b4907becaece0a75271db9bff">data</a>(), m_glu.ucol.<a class="code" href="class_eigen_1_1_plain_object_base.html#a5020fe0b4907becaece0a75271db9bff">data</a>() ); </div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  </div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Success</a>;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  m_factorizationIsOk = <span class="keyword">true</span>;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;}</div><div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a6cb30e5fc6e55e741fb091cc131a0835"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a6cb30e5fc6e55e741fb091cc131a0835">Eigen::internal::SparseLUImpl::copy_to_ucol</a></div><div class="ttdeci">Index copy_to_ucol(const Index jcol, const Index nseg, IndexVector &amp;segrep, BlockIndexVector repfnz, IndexVector &amp;perm_r, BlockScalarVector dense, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs numeric block updates (sup-col) in topological order. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__copy__to__ucol_8h_source.html#l00050">SparseLU_copy_to_ucol.h:50</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_aa17e3d1176edfa0365f5de8928739bfd"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#aa17e3d1176edfa0365f5de8928739bfd">Eigen::internal::SparseLUImpl::pruneL</a></div><div class="ttdeci">void pruneL(const Index jcol, const IndexVector &amp;perm_r, const Index pivrow, const Index nseg, const IndexVector &amp;segrep, BlockIndexVector repfnz, IndexVector &amp;xprune, GlobalLU_t &amp;glu)</div><div class="ttdoc">Prunes the L-structure. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__prune_l_8h_source.html#l00053">SparseLU_pruneL.h:53</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix_html_a370002c463c9be228844280f6f441af6"><div class="ttname"><a href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html#a370002c463c9be228844280f6f441af6">Eigen::internal::MappedSuperNodalMatrix::setInfos</a></div><div class="ttdeci">void setInfos(Index m, Index n, ScalarVector &amp;nzval, IndexVector &amp;nzval_colptr, IndexVector &amp;rowind, IndexVector &amp;rowind_colptr, IndexVector &amp;col_to_sup, IndexVector &amp;sup_to_col)</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u___supernodal_matrix_8h_source.html#l00061">SparseLU_SupernodalMatrix.h:61</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a4e432734e3c35cc52ca11e61942a8d4b"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a4e432734e3c35cc52ca11e61942a8d4b">Eigen::internal::SparseLUImpl::relax_snode</a></div><div class="ttdeci">void relax_snode(const Index n, IndexVector &amp;et, const Index relax_columns, IndexVector &amp;descendants, IndexVector &amp;relax_end)</div><div class="ttdoc">Identify the initial relaxed supernodes. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__relax__snode_8h_source.html#l00047">SparseLU_relax_snode.h:47</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a60e574bcb97bd1d210c4d110529b4c89"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a60e574bcb97bd1d210c4d110529b4c89">Eigen::SparseMatrix::cols</a></div><div class="ttdeci">Index cols() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00121">SparseMatrix.h:121</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a1a577417a1cfe48f1e051651dc7e015b"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a1a577417a1cfe48f1e051651dc7e015b">Eigen::internal::SparseLUImpl::fixupL</a></div><div class="ttdeci">void fixupL(const Index n, const IndexVector &amp;perm_r, GlobalLU_t &amp;glu)</div><div class="ttdoc">Fix up the data storage lsub for L-subscripts. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u___utils_8h_source.html#l00052">SparseLU_Utils.h:52</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_l_u_html_a465989d7a0565f9bbe02836dd6586b92"><div class="ttname"><a href="class_eigen_1_1_sparse_l_u.html#a465989d7a0565f9bbe02836dd6586b92">Eigen::SparseLU::info</a></div><div class="ttdeci">ComputationInfo info() const </div><div class="ttdoc">Reports whether previous computation was successful. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u_8h_source.html#l00207">SparseLU.h:207</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a55a8c8bc53a972811bda8909b2d17443"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a55a8c8bc53a972811bda8909b2d17443">Eigen::SparseMatrix::uncompress</a></div><div class="ttdeci">void uncompress()</div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00478">SparseMatrix.h:478</a></div></div>
<div class="ttc" id="classmatrix_html"><div class="ttname"><a href="classmatrix.html">matrix</a></div><div class="ttdef"><b>Definition:</b> <a href="math3d_8h_source.html#l00219">math3d.h:219</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_a0e0fda6e84d69e02432e4770359bb532"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#a0e0fda6e84d69e02432e4770359bb532">Eigen::PermutationBase::resize</a></div><div class="ttdeci">void resize(Index newSize)</div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00142">PermutationMatrix.h:142</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a691fafc0d103de24f5d9da43b6168179"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a691fafc0d103de24f5d9da43b6168179">Eigen::internal::SparseLUImpl::pivotL</a></div><div class="ttdeci">Index pivotL(const Index jcol, const RealScalar &amp;diagpivotthresh, IndexVector &amp;perm_r, IndexVector &amp;iperm_c, Index &amp;pivrow, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs the numerical pivotin on the current column of L, and the CDIV operation. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__pivot_l_8h_source.html#l00060">SparseLU_pivotL.h:60</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_ac85d6120f30c302c0a3164068c452dec"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#ac85d6120f30c302c0a3164068c452dec">Eigen::SparseMatrix::rows</a></div><div class="ttdeci">Index rows() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00119">SparseMatrix.h:119</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a0277ddb3afdbba94b915897ea1aa0323"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a0277ddb3afdbba94b915897ea1aa0323">Eigen::SparseMatrix::nonZeros</a></div><div class="ttdeci">Index nonZeros() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00246">SparseMatrix.h:246</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a056d27d2f8d025109c8176f319a7821e"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a056d27d2f8d025109c8176f319a7821e">Eigen::internal::SparseLUImpl::countnz</a></div><div class="ttdeci">void countnz(const Index n, Index &amp;nnzL, Index &amp;nnzU, GlobalLU_t &amp;glu)</div><div class="ttdoc">Count Nonzero elements in the factors. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u___utils_8h_source.html#l00021">SparseLU_Utils.h:21</a></div></div>
<div class="ttc" id="group__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">Eigen::NumericalIssue</a></div><div class="ttdef"><b>Definition:</b> <a href="_constants_8h_source.html#l00378">Constants.h:378</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_ad0840b6b32610849ace18f86af6ada25"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#ad0840b6b32610849ace18f86af6ada25">Eigen::internal::SparseLUImpl::heap_relax_snode</a></div><div class="ttdeci">void heap_relax_snode(const Index n, IndexVector &amp;et, const Index relax_columns, IndexVector &amp;descendants, IndexVector &amp;relax_end)</div><div class="ttdoc">Identify the initial relaxed supernodes. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__heap__relax__snode_8h_source.html#l00046">SparseLU_heap_relax_snode.h:46</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_aaaeee6ff7667d743c96986081f62d751"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#aaaeee6ff7667d743c96986081f62d751">Eigen::internal::SparseLUImpl::panel_dfs</a></div><div class="ttdeci">void panel_dfs(const Index m, const Index w, const Index jcol, MatrixType &amp;A, IndexVector &amp;perm_r, Index &amp;nseg, ScalarVector &amp;dense, IndexVector &amp;panel_lsub, IndexVector &amp;segrep, IndexVector &amp;repfnz, IndexVector &amp;xprune, IndexVector &amp;marker, IndexVector &amp;parent, IndexVector &amp;xplore, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs a symbolic factorization on a panel of columns [jcol, jcol+w) </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__panel__dfs_8h_source.html#l00219">SparseLU_panel_dfs.h:219</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_af9945782ef14205cc9fe5d0723394ab9"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#af9945782ef14205cc9fe5d0723394ab9">Eigen::internal::SparseLUImpl::memInit</a></div><div class="ttdeci">Index memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, GlobalLU_t &amp;glu)</div><div class="ttdoc">Allocate various working space for the numerical factorization phase. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u___memory_8h_source.html#l00139">SparseLU_Memory.h:139</a></div></div>
<div class="ttc" id="class_eigen_1_1_plain_object_base_html_aae4f6fbe5e26385a638ad5fa96c69260"><div class="ttname"><a href="class_eigen_1_1_plain_object_base.html#aae4f6fbe5e26385a638ad5fa96c69260">Eigen::PlainObjectBase::setConstant</a></div><div class="ttdeci">Derived &amp; setConstant(Index size, const Scalar &amp;value)</div><div class="ttdef"><b>Definition:</b> <a href="_cwise_nullary_op_8h_source.html#l00348">CwiseNullaryOp.h:348</a></div></div>
<div class="ttc" id="group__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Eigen::Success</a></div><div class="ttdef"><b>Definition:</b> <a href="_constants_8h_source.html#l00376">Constants.h:376</a></div></div>
<div class="ttc" id="class_eigen_1_1_plain_object_base_html_a5020fe0b4907becaece0a75271db9bff"><div class="ttname"><a href="class_eigen_1_1_plain_object_base.html#a5020fe0b4907becaece0a75271db9bff">Eigen::PlainObjectBase::data</a></div><div class="ttdeci">EIGEN_STRONG_INLINE const Scalar * data() const </div><div class="ttdef"><b>Definition:</b> <a href="_plain_object_base_8h_source.html#l00209">PlainObjectBase.h:209</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a7e8fad25e9562c5231e81fe8ed61db16"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a7e8fad25e9562c5231e81fe8ed61db16">Eigen::internal::SparseLUImpl::panel_bmod</a></div><div class="ttdeci">void panel_bmod(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector &amp;dense, ScalarVector &amp;tempv, IndexVector &amp;segrep, IndexVector &amp;repfnz, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs numeric block updates (sup-panel) in topological order. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__panel__bmod_8h_source.html#l00056">SparseLU_panel_bmod.h:56</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_ac637509429ed2e8aa3b846b9e02da8e4"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#ac637509429ed2e8aa3b846b9e02da8e4">Eigen::PermutationBase::size</a></div><div class="ttdeci">Index size() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00114">PermutationMatrix.h:114</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_ac76a65c37b2bc5043b17b9f8b6dab580"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#ac76a65c37b2bc5043b17b9f8b6dab580">Eigen::SparseMatrix::innerNonZeroPtr</a></div><div class="ttdeci">const Index * innerNonZeroPtr() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00158">SparseMatrix.h:158</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_matrix_html_a523ff8c60307b5e9f27526599185acd3"><div class="ttname"><a href="class_eigen_1_1_permutation_matrix.html#a523ff8c60307b5e9f27526599185acd3">Eigen::PermutationMatrix::indices</a></div><div class="ttdeci">const IndicesType &amp; indices() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00358">PermutationMatrix.h:358</a></div></div>
<div class="ttc" id="class_eigen_1_1_permutation_base_html_acd5b0470479df2b040bfadd6937cb4c9"><div class="ttname"><a href="class_eigen_1_1_permutation_base.html#acd5b0470479df2b040bfadd6937cb4c9">Eigen::PermutationBase::inverse</a></div><div class="ttdeci">Transpose&lt; PermutationBase &gt; inverse() const </div><div class="ttdef"><b>Definition:</b> <a href="_permutation_matrix_8h_source.html#l00201">PermutationMatrix.h:201</a></div></div>
<div class="ttc" id="class_eigen_1_1_plain_object_base_html_ab8b732ae4d45271b2532978ee13210d1"><div class="ttname"><a href="class_eigen_1_1_plain_object_base.html#ab8b732ae4d45271b2532978ee13210d1">Eigen::PlainObjectBase::setZero</a></div><div class="ttdeci">Derived &amp; setZero(Index size)</div><div class="ttdef"><b>Definition:</b> <a href="_cwise_nullary_op_8h_source.html#l00515">CwiseNullaryOp.h:515</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_ab08e94104581b16697bd7b5828cb8507"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#ab08e94104581b16697bd7b5828cb8507">Eigen::internal::SparseLUImpl::column_dfs</a></div><div class="ttdeci">Index column_dfs(const Index m, const Index jcol, IndexVector &amp;perm_r, Index maxsuper, Index &amp;nseg, BlockIndexVector lsub_col, IndexVector &amp;segrep, BlockIndexVector repfnz, IndexVector &amp;xprune, IndexVector &amp;marker, IndexVector &amp;parent, IndexVector &amp;xplore, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs a symbolic factorization on column jcol and decide the supernode boundary. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__column__dfs_8h_source.html#l00093">SparseLU_column_dfs.h:93</a></div></div>
<div class="ttc" id="class_eigen_1_1_sparse_matrix_html_a6f4be33f4f94c86f003fda0c5c7911b2"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a6f4be33f4f94c86f003fda0c5c7911b2">Eigen::SparseMatrix::outerIndexPtr</a></div><div class="ttdeci">const Index * outerIndexPtr() const </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_matrix_8h_source.html#l00149">SparseMatrix.h:149</a></div></div>
<div class="ttc" id="class_eigen_1_1internal_1_1_sparse_l_u_impl_html_a0979f09ffe0983fdff318e3dbf2eef68"><div class="ttname"><a href="class_eigen_1_1internal_1_1_sparse_l_u_impl.html#a0979f09ffe0983fdff318e3dbf2eef68">Eigen::internal::SparseLUImpl::column_bmod</a></div><div class="ttdeci">Index column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector &amp;tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs numeric block updates (sup-col) in topological order. </div><div class="ttdef"><b>Definition:</b> <a href="_sparse_l_u__column__bmod_8h_source.html#l00053">SparseLU_column_bmod.h:53</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a465989d7a0565f9bbe02836dd6586b92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether previous computation was successful. </p>
<dl class="section return"><dt>Returns</dt><dd><code>Success</code> if computation was succesful, <code>NumericalIssue</code> if the <a class="el" href="class_eigen_1_1_l_u.html">LU</a> factorization reports a problem, zero diagonal for instance <code>InvalidInput</code> if the input matrix is invalid</dd></dl>
<dl class="section see"><dt>See also</dt><dd>iparm() </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00207">207</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    {</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      eigen_assert(m_isInitialized &amp;&amp; <span class="stringliteral">&quot;Decomposition is not initialized.&quot;</span>);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      <span class="keywordflow">return</span> m_info;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afff3bd506cd78172e5219c707562729f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that the pattern of the input matrix is symmetric </p>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00123">123</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      m_symmetricmode = sym;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1866df3ffb444b0797a5cd1cb87e000f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::lastErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string describing the type of error </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00216">216</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      <span class="keywordflow">return</span> m_lastError; </div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a78b4e23dc8beb49dd4bdae2ba3407564"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::logAbsDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the natural log of the absolute value of the determinant of the matrix of which **this is the <a class="el" href="class_eigen_1_1_q_r.html">QR</a> decomposition</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is useful to work around the risk of overflow/underflow that's inherent to the determinant computation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#a06fa89424239fb169d408f08252426d0">absDeterminant()</a>, <a class="el" href="class_eigen_1_1_sparse_l_u.html#a6651143e3b18fa90cfb3808b6fd23c4e">signDeterminant()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00286">286</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;     {</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;       eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;       Scalar det = Scalar(0.);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;       <span class="keywordflow">for</span> (Index j = 0; j &lt; this-&gt;cols(); ++j)</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;       {</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;         <span class="keywordflow">for</span> (<span class="keyword">typename</span> SCMatrix::InnerIterator it(m_Lstore, j); it; ++it)</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;         {</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;           <span class="keywordflow">if</span>(it.row() &lt; j) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;           <span class="keywordflow">if</span>(it.row() == j)</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;           {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;             det += (std::log)((std::abs)(it.value()));</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;             <span class="keywordflow">break</span>;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;           }</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;         }</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;       }</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;       <span class="keywordflow">return</span> det;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;     }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5eb96e32259c4d8a56ff7106e2aa5a78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_sparse_l_u_matrix_l_return_type.html">SparseLUMatrixLReturnType</a>&lt;<a class="el" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html">SCMatrix</a>&gt; <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::matrixL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix L, internally stored as supernodes The only operation available with this expression is the triangular solve <div class="fragment"><div class="line">y = b; <a class="code" href="class_eigen_1_1_sparse_l_u.html#a5eb96e32259c4d8a56ff7106e2aa5a78">matrixL</a>().solveInPlace(y);</div></div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00134">134</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;      <span class="keywordflow">return</span> SparseLUMatrixLReturnType&lt;SCMatrix&gt;(m_Lstore);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aafa9ef8da7dff41e3f9a0fbe1f466365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_sparse_l_u_matrix_u_return_type.html">SparseLUMatrixUReturnType</a>&lt;<a class="el" href="class_eigen_1_1internal_1_1_mapped_super_nodal_matrix.html">SCMatrix</a>,<a class="el" href="class_eigen_1_1_mapped_sparse_matrix.html">MappedSparseMatrix</a>&lt;Scalar,ColMajor,Index&gt; &gt; <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::matrixU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix U, The only operation available with this expression is the triangular solve <div class="fragment"><div class="line">y = b; <a class="code" href="class_eigen_1_1_sparse_l_u.html#aafa9ef8da7dff41e3f9a0fbe1f466365">matrixU</a>().solveInPlace(y);</div></div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00144">144</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;      <span class="keywordflow">return</span> SparseLUMatrixUReturnType&lt;SCMatrix, MappedSparseMatrix&lt;Scalar,ColMajor,Index&gt; &gt;(m_Lstore, m_Ustore);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae2316b6a3f3bc779884f2450e798538b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationType</a>&amp; <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::rowsPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the row matrix permutation <img class="formulaInl" alt="$ P_r $" src="form_201.png"/> such that <img class="formulaInl" alt="$P_r A P_c^T = L U$" src="form_202.png"/> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#a653db904a2a95add81ef8db1a13c0a0c">colsPermutation()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00153">153</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      <span class="keywordflow">return</span> m_perm_r;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a94c726c9ebb71a60b529fe47d942ad57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::setPivotThreshold </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>thresh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the threshold used for a diagonal entry to be an acceptable pivot. </p>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00166">166</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      m_diagpivotthresh = thresh; </div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6651143e3b18fa90cfb3808b6fd23c4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::signDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A number representing the sign of the determinant</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#a06fa89424239fb169d408f08252426d0">absDeterminant()</a>, <a class="el" href="class_eigen_1_1_sparse_l_u.html#a78b4e23dc8beb49dd4bdae2ba3407564">logAbsDeterminant()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00309">309</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;     {</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;       eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;       <span class="keywordflow">return</span> Scalar(m_detPermR);</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;     }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a64c51ef69c29cb7e8e621ebc70dc4fef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<div class="memtemplate">
template&lt;typename Rhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_eigen_1_1internal_1_1solve__retval.html">internal::solve_retval</a>&lt;<a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>, Rhs&gt; <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Rhs &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the solution X of <img class="formulaInl" alt="$ A X = B $" src="form_204.png"/> using the current decomposition of A.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the destination matrix X in X = this-&gt;solve(B) must be colmun-major.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#a96a8dcb02015ab9be5777d4ba9173266">compute()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00178">178</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;SparseLU is not initialized.&quot;</span>); </div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;      eigen_assert(rows()==B.rows()</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                    &amp;&amp; <span class="stringliteral">&quot;SparseLU::solve(): invalid number of rows of the right hand side matrix B&quot;</span>);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;          <span class="keywordflow">return</span> internal::solve_retval&lt;SparseLU, Rhs&gt;(*<span class="keyword">this</span>, B.derived());</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0cadeb083cf0ccaf093e9953e2207169"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<div class="memtemplate">
template&lt;typename Rhs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_eigen_1_1internal_1_1sparse__solve__retval.html">internal::sparse_solve_retval</a>&lt;<a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>, Rhs&gt; <a class="el" href="class_eigen_1_1_sparse_l_u.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Rhs &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the solution X of <img class="formulaInl" alt="$ A X = B $" src="form_204.png"/> using the current decomposition of A.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_l_u.html#a96a8dcb02015ab9be5777d4ba9173266">compute()</a> </dd></dl>

<p>Definition at line <a class="el" href="_sparse_l_u_8h_source.html#l00191">191</a> of file <a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    {</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;SparseLU is not initialized.&quot;</span>); </div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      eigen_assert(rows()==B.rows()</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    &amp;&amp; <span class="stringliteral">&quot;SparseLU::solve(): invalid number of rows of the right hand side matrix B&quot;</span>);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;          <span class="keywordflow">return</span> internal::sparse_solve_retval&lt;SparseLU, Rhs&gt;(*<span class="keyword">this</span>, B.derived());</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Brig/Documents/ShapeWorksStudio/src/Surfworks/Eigen/src/SparseLU/<a class="el" href="_sparse_l_u_8h_source.html">SparseLU.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 15 2016 13:47:58 for Shapeworks Studio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
