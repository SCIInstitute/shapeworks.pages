<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Shapeworks Studio: itk::PSMParticleEntropyFunction&lt; TGradientNumericType, VDimension &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="splash.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shapeworks Studio
   &#160;<span id="projectnumber">2.1</span>
   </div>
   <div id="projectbrief">Shape analysis software suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="https://github.com/SCIInstitute/ShapeWorksStudio"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>itk</b></li><li class="navelem"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classitk_1_1_p_s_m_particle_entropy_function-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">itk::PSMParticleEntropyFunction&lt; TGradientNumericType, VDimension &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This function returns an estimate of the gradient of the entropy of a particle distribution with respect to change in position of a specific particle in that distribution.  
 <a href="classitk_1_1_p_s_m_particle_entropy_function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for itk::PSMParticleEntropyFunction&lt; TGradientNumericType, VDimension &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classitk_1_1_p_s_m_particle_entropy_function__inherit__graph.png" border="0" usemap="#itk_1_1_p_s_m_particle_entropy_function_3_01_t_gradient_numeric_type_00_01_v_dimension_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="itk_1_1_p_s_m_particle_entropy_function_3_01_t_gradient_numeric_type_00_01_v_dimension_01_4_inherit__map" id="itk_1_1_p_s_m_particle_entropy_function_3_01_t_gradient_numeric_type_00_01_v_dimension_01_4_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for itk::PSMParticleEntropyFunction&lt; TGradientNumericType, VDimension &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classitk_1_1_p_s_m_particle_entropy_function__coll__graph.png" border="0" usemap="#itk_1_1_p_s_m_particle_entropy_function_3_01_t_gradient_numeric_type_00_01_v_dimension_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="itk_1_1_p_s_m_particle_entropy_function_3_01_t_gradient_numeric_type_00_01_v_dimension_01_4_coll__map" id="itk_1_1_p_s_m_particle_entropy_function_3_01_t_gradient_numeric_type_00_01_v_dimension_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8d34bc491e4802e0d869156a555dadd0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a8d34bc491e4802e0d869156a555dadd0">Self</a></td></tr>
<tr class="separator:a8d34bc491e4802e0d869156a555dadd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdacb15d1138e62443f9f03cf564fdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefdacb15d1138e62443f9f03cf564fdc"></a>
typedef SmartPointer&lt; <a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pointer</b></td></tr>
<tr class="separator:aefdacb15d1138e62443f9f03cf564fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86069999b5156ae8dd2b7bc2ef5d55d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86069999b5156ae8dd2b7bc2ef5d55d6"></a>
typedef SmartPointer&lt; const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstPointer</b></td></tr>
<tr class="separator:a86069999b5156ae8dd2b7bc2ef5d55d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380eba67267c1fc1cae91cac3713dd61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a380eba67267c1fc1cae91cac3713dd61"></a>
typedef <a class="el" href="classitk_1_1_p_s_m_cost_function.html">PSMCostFunction</a>&lt; VDimension &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Superclass</b></td></tr>
<tr class="separator:a380eba67267c1fc1cae91cac3713dd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c298da50f00a6eda614d23fc7224b22"><td class="memItemLeft" align="right" valign="top">typedef TGradientNumericType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a0c298da50f00a6eda614d23fc7224b22">GradientNumericType</a></td></tr>
<tr class="separator:a0c298da50f00a6eda614d23fc7224b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba162690ed577b95fc87ab91a838cc53"><td class="memItemLeft" align="right" valign="top">typedef Superclass::ParticleSystemType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#aba162690ed577b95fc87ab91a838cc53">ParticleSystemType</a></td></tr>
<tr class="separator:aba162690ed577b95fc87ab91a838cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1773d7f2f6b247826a73653920e1616"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitk_1_1_p_s_m_container_array_attribute.html">PSMContainerArrayAttribute</a>&lt; double, VDimension &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab1773d7f2f6b247826a73653920e1616">SigmaCacheType</a></td></tr>
<tr class="separator:ab1773d7f2f6b247826a73653920e1616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56789bd108f4f9e4f599c523bab324cf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">Superclass::VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a56789bd108f4f9e4f599c523bab324cf">VectorType</a></td></tr>
<tr class="separator:a56789bd108f4f9e4f599c523bab324cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add92db6a6abda3dc6c24eb3651355a11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add92db6a6abda3dc6c24eb3651355a11"></a>
typedef <a class="el" href="classitk_1_1_p_s_m_particle_system.html#a18d9a99c8893450ced873f161c163824">ParticleSystemType::PointType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PointType</b></td></tr>
<tr class="separator:add92db6a6abda3dc6c24eb3651355a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a31fe3b2179b86611190cc0bc6e2922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a31fe3b2179b86611190cc0bc6e2922"></a>
typedef vnl_vector_fixed&lt; TGradientNumericType, VDimension &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GradientVectorType</b></td></tr>
<tr class="separator:a9a31fe3b2179b86611190cc0bc6e2922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classitk_1_1_p_s_m_cost_function"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classitk_1_1_p_s_m_cost_function')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classitk_1_1_p_s_m_cost_function.html">itk::PSMCostFunction&lt; VDimension &gt;</a></td></tr>
<tr class="memitem:ac40d4243a5e2b4336e1f8b88ad88b6e4 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitk_1_1_p_s_m_cost_function.html">PSMCostFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a></td></tr>
<tr class="separator:ac40d4243a5e2b4336e1f8b88ad88b6e4 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408737fa9ab9cb0e7dc614e4d992c6cb inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a408737fa9ab9cb0e7dc614e4d992c6cb"></a>
typedef SmartPointer&lt; <a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pointer</b></td></tr>
<tr class="separator:a408737fa9ab9cb0e7dc614e4d992c6cb inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d5aff4104a1b299eae21fa27b1ffb6 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7d5aff4104a1b299eae21fa27b1ffb6"></a>
typedef SmartPointer&lt; const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstPointer</b></td></tr>
<tr class="separator:af7d5aff4104a1b299eae21fa27b1ffb6 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39742ae0b57ed0685ed5a5852d4ab39 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab39742ae0b57ed0685ed5a5852d4ab39"></a>
typedef LightObject&#160;</td><td class="memItemRight" valign="bottom"><b>Superclass</b></td></tr>
<tr class="separator:ab39742ae0b57ed0685ed5a5852d4ab39 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6ac356e0de52fa2501693365e99b1a inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitk_1_1_p_s_m_particle_system.html">PSMParticleSystem</a>&lt; VDimension &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a></td></tr>
<tr class="separator:a8f6ac356e0de52fa2501693365e99b1a inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4fea2a4b48b347792f34a483fb68e4 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">typedef vnl_vector_fixed&lt; double, VDimension &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">VectorType</a></td></tr>
<tr class="separator:aca4fea2a4b48b347792f34a483fb68e4 inherit pub_types_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef708821e6ef680cfa8a3a141df0a787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef708821e6ef680cfa8a3a141df0a787"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkTypeMacro</b> (<a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a>, <a class="el" href="classitk_1_1_p_s_m_cost_function.html">PSMCostFunction</a>)</td></tr>
<tr class="separator:aef708821e6ef680cfa8a3a141df0a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955516abce26641103d4776f6d8bf5fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a955516abce26641103d4776f6d8bf5fb">itkNewMacro</a> (<a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a>)</td></tr>
<tr class="separator:a955516abce26641103d4776f6d8bf5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f776274c9eba3afe1c906a2b9ae894"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a43f776274c9eba3afe1c906a2b9ae894">itkStaticConstMacro</a> (Dimension, unsigned int, VDimension)</td></tr>
<tr class="separator:a43f776274c9eba3afe1c906a2b9ae894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857974694f2642509411e0f41a4d324c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a857974694f2642509411e0f41a4d324c">Evaluate</a> (unsigned int, unsigned int, const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *, double &amp;) const </td></tr>
<tr class="separator:a857974694f2642509411e0f41a4d324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0007641be062bf6f3db8b1fd907ab901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0007641be062bf6f3db8b1fd907ab901"></a>
virtual <a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Evaluate</b> (unsigned int, unsigned int, const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *, double &amp;, double &amp;) const </td></tr>
<tr class="separator:a0007641be062bf6f3db8b1fd907ab901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4432bd0547ba868803f467c8342c298a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4432bd0547ba868803f467c8342c298a"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>Energy</b> (unsigned int, unsigned int, const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *) const </td></tr>
<tr class="separator:a4432bd0547ba868803f467c8342c298a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094383aa40558ab47943f7ef29870544"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a094383aa40558ab47943f7ef29870544">ResetBuffers</a> ()</td></tr>
<tr class="separator:a094383aa40558ab47943f7ef29870544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76baba9c8bcd9cf1686c00ea39c2f06"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab76baba9c8bcd9cf1686c00ea39c2f06">EstimateSigma</a> (unsigned int, const typename ParticleSystemType::PointVectorType &amp;, const std::vector&lt; double &gt; &amp;, const <a class="el" href="class_point.html">PointType</a> &amp;, double, double, int &amp;err) const </td></tr>
<tr class="separator:ab76baba9c8bcd9cf1686c00ea39c2f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c96f778416c61de52462db16fedd11"><td class="memItemLeft" align="right" valign="top">TGradientNumericType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a97c96f778416c61de52462db16fedd11">AngleCoefficient</a> (const GradientVectorType &amp;, const GradientVectorType &amp;) const </td></tr>
<tr class="separator:a97c96f778416c61de52462db16fedd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bfb82384a54f2d8f8f41f68b34203f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#af6bfb82384a54f2d8f8f41f68b34203f">SetMinimumNeighborhoodRadius</a> (double s)</td></tr>
<tr class="separator:af6bfb82384a54f2d8f8f41f68b34203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba20892f0bd93859f7c6f24d06d3ef3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba20892f0bd93859f7c6f24d06d3ef3b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetMinimumNeighborhoodRadius</b> () const </td></tr>
<tr class="separator:aba20892f0bd93859f7c6f24d06d3ef3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4d3efccb4fd97484750d1c8c0344a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a5a4d3efccb4fd97484750d1c8c0344a0">SetMaximumNeighborhoodRadius</a> (double s)</td></tr>
<tr class="separator:a5a4d3efccb4fd97484750d1c8c0344a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd9952c72eca1115d0dc1ef7274d0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9fd9952c72eca1115d0dc1ef7274d0b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetMaximumNeighborhoodRadius</b> () const </td></tr>
<tr class="separator:af9fd9952c72eca1115d0dc1ef7274d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd36d130fbbf6a2ee4fb3b23e92261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a08fd36d130fbbf6a2ee4fb3b23e92261">SetFlatCutoff</a> (double s)</td></tr>
<tr class="separator:a08fd36d130fbbf6a2ee4fb3b23e92261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af813fc7c7e974db33d9cbe13cc53044f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af813fc7c7e974db33d9cbe13cc53044f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlatCutoff</b> () const </td></tr>
<tr class="separator:af813fc7c7e974db33d9cbe13cc53044f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e1b9fd11d6d2c9a7cab2529b59395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#afb8e1b9fd11d6d2c9a7cab2529b59395">SetNeighborhoodToSigmaRatio</a> (double s)</td></tr>
<tr class="separator:afb8e1b9fd11d6d2c9a7cab2529b59395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee0dc5fac8c2e72af86bed67f68059"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ee0dc5fac8c2e72af86bed67f68059"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetNeighborhoodToSigmaRatio</b> () const </td></tr>
<tr class="separator:af5ee0dc5fac8c2e72af86bed67f68059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26221a57fc80d44af4eb584b0335f1f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a26221a57fc80d44af4eb584b0335f1f2">SetSpatialSigmaCache</a> (<a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab1773d7f2f6b247826a73653920e1616">SigmaCacheType</a> *s)</td></tr>
<tr class="separator:a26221a57fc80d44af4eb584b0335f1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8c9f597597e75d2663284b2c61953d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d8c9f597597e75d2663284b2c61953d"></a>
<a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab1773d7f2f6b247826a73653920e1616">SigmaCacheType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSpatialSigmaCache</b> ()</td></tr>
<tr class="separator:a6d8c9f597597e75d2663284b2c61953d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8472b7110cae0f391d7ec34e4477c2e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8472b7110cae0f391d7ec34e4477c2e2"></a>
const <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab1773d7f2f6b247826a73653920e1616">SigmaCacheType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSpatialSigmaCache</b> () const </td></tr>
<tr class="separator:a8472b7110cae0f391d7ec34e4477c2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2789eb597d229e8b7c765022af18144b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a2789eb597d229e8b7c765022af18144b">ComputeAngularWeights</a> (const <a class="el" href="class_point.html">PointType</a> &amp;, const typename ParticleSystemType::PointVectorType &amp;, const <a class="el" href="classitk_1_1_p_s_m_image_domain_with_gradients.html">PSMImageDomainWithGradients</a>&lt; TGradientNumericType, VDimension &gt; *, std::vector&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a2789eb597d229e8b7c765022af18144b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classitk_1_1_p_s_m_cost_function"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classitk_1_1_p_s_m_cost_function')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classitk_1_1_p_s_m_cost_function.html">itk::PSMCostFunction&lt; VDimension &gt;</a></td></tr>
<tr class="memitem:aeb1422a24dcb0e7b95f6897253e80508 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1422a24dcb0e7b95f6897253e80508"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkTypeMacro</b> (<a class="el" href="classitk_1_1_p_s_m_cost_function.html">PSMCostFunction</a>, LightObject)</td></tr>
<tr class="separator:aeb1422a24dcb0e7b95f6897253e80508 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb272bcf5b27f4cb27ef6ed9e25face inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#a3bb272bcf5b27f4cb27ef6ed9e25face">itkStaticConstMacro</a> (Dimension, unsigned int, VDimension)</td></tr>
<tr class="separator:a3bb272bcf5b27f4cb27ef6ed9e25face inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afcc2705c3bb0662da4209a44e3e466 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#a4afcc2705c3bb0662da4209a44e3e466">AfterIteration</a> ()</td></tr>
<tr class="separator:a4afcc2705c3bb0662da4209a44e3e466 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ca697c0c1b75589eba4d7a253720b9 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac0ca697c0c1b75589eba4d7a253720b9">BeforeIteration</a> ()</td></tr>
<tr class="separator:ac0ca697c0c1b75589eba4d7a253720b9 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57aa58239d903420eef15abdf6abcebb inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#a57aa58239d903420eef15abdf6abcebb">BeforeEvaluate</a> (unsigned int, unsigned int, const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *)</td></tr>
<tr class="separator:a57aa58239d903420eef15abdf6abcebb inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe632251832b5c8f93e610adc9738c3a inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#abe632251832b5c8f93e610adc9738c3a">SetParticleSystem</a> (<a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *p)</td></tr>
<tr class="separator:abe632251832b5c8f93e610adc9738c3a inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707567c40987aabf4c84147fa76d806d inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a707567c40987aabf4c84147fa76d806d"></a>
virtual <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetParticleSystem</b> () const </td></tr>
<tr class="separator:a707567c40987aabf4c84147fa76d806d inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3978d42f43c01610167745b53f252d16 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3978d42f43c01610167745b53f252d16"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetDomainNumber</b> (unsigned int i)</td></tr>
<tr class="separator:a3978d42f43c01610167745b53f252d16 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47654dbdeefaec19f0145e4a824ff3 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada47654dbdeefaec19f0145e4a824ff3"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>GetDomainNumber</b> () const </td></tr>
<tr class="separator:ada47654dbdeefaec19f0145e4a824ff3 inherit pub_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a274a595bb81a5be22e2300ede2888787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a274a595bb81a5be22e2300ede2888787"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a> &amp;)</td></tr>
<tr class="separator:a274a595bb81a5be22e2300ede2888787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6579e9ed8e82819af0a55e5f60c46dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6579e9ed8e82819af0a55e5f60c46dcb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PSMParticleEntropyFunction</b> (const <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a> &amp;)</td></tr>
<tr class="separator:a6579e9ed8e82819af0a55e5f60c46dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classitk_1_1_p_s_m_cost_function"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classitk_1_1_p_s_m_cost_function')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classitk_1_1_p_s_m_cost_function.html">itk::PSMCostFunction&lt; VDimension &gt;</a></td></tr>
<tr class="memitem:a995fb15d48b1fa4efe67d048e49d4955 inherit pro_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995fb15d48b1fa4efe67d048e49d4955"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classitk_1_1_p_s_m_cost_function.html">PSMCostFunction</a> &amp;)</td></tr>
<tr class="separator:a995fb15d48b1fa4efe67d048e49d4955 inherit pro_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86c8b502ef29e8043e6525d50cf499a inherit pro_methods_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac86c8b502ef29e8043e6525d50cf499a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PSMCostFunction</b> (const <a class="el" href="classitk_1_1_p_s_m_cost_function.html">PSMCostFunction</a> &amp;)</td></tr>
<tr class="separator:ac86c8b502ef29e8043e6525d50cf499a inherit pro_methods_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aac61d5c92e0710076b7ef7ce8bfed58e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac61d5c92e0710076b7ef7ce8bfed58e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_MinimumNeighborhoodRadius</b></td></tr>
<tr class="separator:aac61d5c92e0710076b7ef7ce8bfed58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce4e9ee425c9d56bb7237d65dd2625c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce4e9ee425c9d56bb7237d65dd2625c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_MaximumNeighborhoodRadius</b></td></tr>
<tr class="separator:afce4e9ee425c9d56bb7237d65dd2625c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe65a37a2bf62bf24a5317049e2b863"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fe65a37a2bf62bf24a5317049e2b863"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_FlatCutoff</b></td></tr>
<tr class="separator:a7fe65a37a2bf62bf24a5317049e2b863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65beb4527d84275f56a54d14c12e31de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65beb4527d84275f56a54d14c12e31de"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_NeighborhoodToSigmaRatio</b></td></tr>
<tr class="separator:a65beb4527d84275f56a54d14c12e31de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120ca1cca7e4695fb037b1a263f6fda7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120ca1cca7e4695fb037b1a263f6fda7"></a>
SigmaCacheType::Pointer&#160;</td><td class="memItemRight" valign="bottom"><b>m_SpatialSigmaCache</b></td></tr>
<tr class="separator:a120ca1cca7e4695fb037b1a263f6fda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classitk_1_1_p_s_m_cost_function"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classitk_1_1_p_s_m_cost_function')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classitk_1_1_p_s_m_cost_function.html">itk::PSMCostFunction&lt; VDimension &gt;</a></td></tr>
<tr class="memitem:ab0d59c387c5d2825af9007e95c4cfda6 inherit pro_attribs_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d59c387c5d2825af9007e95c4cfda6"></a>
<a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_ParticleSystem</b></td></tr>
<tr class="separator:ab0d59c387c5d2825af9007e95c4cfda6 inherit pro_attribs_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81768f19794eefbc05de5e7e6beda26 inherit pro_attribs_classitk_1_1_p_s_m_cost_function"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae81768f19794eefbc05de5e7e6beda26"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_DomainNumber</b></td></tr>
<tr class="separator:ae81768f19794eefbc05de5e7e6beda26 inherit pro_attribs_classitk_1_1_p_s_m_cost_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TGradientNumericType, unsigned int VDimension&gt;<br />
class itk::PSMParticleEntropyFunction&lt; TGradientNumericType, VDimension &gt;</h3>

<p>This function returns an estimate of the gradient of the entropy of a particle distribution with respect to change in position of a specific particle in that distribution. </p>
<p>The following description is an excerpt from</p>
<p>J Cates, P T Fletcher, M Styner, M Shenton, R Whitaker. <a class="el" href="class_shape.html" title="Representation of a single shape/patient. ">Shape</a> Modeling and Analysis with Entropy-Based Particle Systems. Information Processing in Medical Imaging IPMI 2007, LNCS 4584, pp. 333–345, 2007.</p>
<p>We treat a surface as a subset of <img class="formulaInl" alt="$\Re^d$" src="form_0.png"/>, where <img class="formulaInl" alt="$d=2$" src="form_1.png"/> or <img class="formulaInl" alt="$d=3$" src="form_2.png"/> depending whether we are processing curves in the plane or surfaces in a volume, refspectively. The method we describe here deals with smooth, closed manifolds of codimension one, and we will refer to such manifolds as {<em>surfaces}</em>. We sample a surface <img class="formulaInl" alt="${\cal S} \subset \Re^d$" src="form_3.png"/> using a discrete set of <img class="formulaInl" alt="$N$" src="form_4.png"/> points that are considered random variables <img class="formulaInl" alt="$Z = (X_1, X_2, \ldots, X_N)$" src="form_5.png"/> drawn from a probability density function (PDF), <img class="formulaInl" alt="$p(X)$" src="form_6.png"/>. We denote a realization of this PDF with lower case, and thus we have <img class="formulaInl" alt="$z = (x_1, x_2,\ldots, x_N)$" src="form_7.png"/>, where <img class="formulaInl" alt="$z \in {\cal S}^N$" src="form_8.png"/>. The probability of a realization <img class="formulaInl" alt="$x$" src="form_9.png"/> is <img class="formulaInl" alt="$p(X = x)$" src="form_10.png"/>, which we denote simply as <img class="formulaInl" alt="$p(x)$" src="form_11.png"/>.</p>
<p>The amount of information contained in such a random sampling is, in the limit, the differential entropy of the PDF, which is <img class="formulaInl" alt="$H[X] = -\int_S p(x) \log p(x) dx = -E\{\log p(X)\}$" src="form_12.png"/>, where <img class="formulaInl" alt="$E\{ \cdot \}$" src="form_13.png"/> is the expectation. When we have a sufficient number of points sampled from <img class="formulaInl" alt="$p$" src="form_14.png"/>, we can approximate the expectation by the sample mean, which gives <img class="formulaInl" alt="$H[X] \approx - (1/N)\sum_{i} \log p(x_i)$" src="form_15.png"/>. We must also estimate <img class="formulaInl" alt="$p(x_i)$" src="form_16.png"/>. Density functions on surfaces can be quite complex, and so we use a nonparametric, Parzen windowing estimation of this density using the particles themselves. Thus we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p(x_i) \approx \frac{1}{N(N-1)} \sum^N_{j=1, j \neq i} G(x_i - x_j, \sigma_i), \]" src="form_17.png"/>
</p>
<p> where <img class="formulaInl" alt="$G(x_i - x_j, \sigma_i)$" src="form_18.png"/> is a <img class="formulaInl" alt="$d$" src="form_19.png"/>-dimensional, isotropic Gaussian with standard deviation <img class="formulaInl" alt="$\sigma_i$" src="form_20.png"/>. The cost function <img class="formulaInl" alt="$C$" src="form_21.png"/>, is therefore an approximation of (negative) entropy: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ -H[X] \approx C(x_1, \dots, x_N) = \sum_{i} \log \frac{1}{N(N-1)} \sum_{j \neq i} G(x_i - x_j, \sigma_i). \]" src="form_22.png"/>
</p>
<dl class="section author"><dt>Author</dt><dd>Josh Cates </dd></dl>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00084">84</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0c298da50f00a6eda614d23fc7224b22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TGradientNumericType <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::<a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#a0c298da50f00a6eda614d23fc7224b22">GradientNumericType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type representing individual gradient components. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00095">95</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba162690ed577b95fc87ab91a838cc53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Superclass::ParticleSystemType <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::<a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of particle system. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00098">98</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d34bc491e4802e0d869156a555dadd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a> <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::<a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard class typedefs. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00088">88</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1773d7f2f6b247826a73653920e1616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classitk_1_1_p_s_m_container_array_attribute.html">PSMContainerArrayAttribute</a>&lt;double, VDimension&gt; <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::<a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab1773d7f2f6b247826a73653920e1616">SigmaCacheType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cache type for the sigma values. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00101">101</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="a56789bd108f4f9e4f599c523bab324cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">Superclass::VectorType</a> <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::<a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">VectorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vector &amp; <a class="el" href="class_point.html">Point</a> types. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00104">104</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a97c96f778416c61de52462db16fedd11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType , unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TGradientNumericType <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::AngleCoefficient </td>
          <td>(</td>
          <td class="paramtype">const GradientVectorType &amp;&#160;</td>
          <td class="paramname"><em>p_i_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GradientVectorType &amp;&#160;</td>
          <td class="paramname"><em>p_j_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a weighting coefficient based on the angle between two vectors. Weights smoothly approach zero as the angle between two normals approaches 90 degrees. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00027">27</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html">itkPSMParticleEntropyFunction.hxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;{</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="comment">// Get the cosine of the angle between the two particles&#39; normals</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  TGradientNumericType cosine = dot_product(p_i_normal,p_j_normal) /</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    (p_i_normal.magnitude()*p_j_normal.magnitude() + 1.0e-6);</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  </div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  <span class="comment">// the flat region</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <span class="keywordflow">if</span> ( cosine &gt;= m_FlatCutoff ) <span class="keywordflow">return</span> 1.0;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  </div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// the feathered region</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="keywordflow">return</span> ( cos( (m_FlatCutoff - cosine) / (1.0+m_FlatCutoff) * (3.14159265358979/2.0) )) ; </div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;} </div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2789eb597d229e8b7c765022af18144b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::ComputeAngularWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point.html">PointType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ParticleSystemType::PointVectorType &amp;&#160;</td>
          <td class="paramname"><em>neighborhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1_p_s_m_image_domain_with_gradients.html">PSMImageDomainWithGradients</a>&lt; TGradientNumericType, VDimension &gt; *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a set of weights based on the difference in the normals of a central point and each of its neighbors. Difference of &gt; 90 degrees results in a weight of 0. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00043">43</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html">itkPSMParticleEntropyFunction.hxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  GradientVectorType posnormal = domain-&gt;SampleNormalVnl(pos, 1.0e-10);</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  weights.resize(neighborhood.size());</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  </div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; neighborhood.size(); i++)</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    weights[i] = this-&gt;<a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a97c96f778416c61de52462db16fedd11">AngleCoefficient</a>(posnormal,</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                                        domain-&gt;SampleNormalVnl(neighborhood[i].Point, 1.0e-10));</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">if</span> (weights[i] &lt; 1.0e-5) weights[i] = 0.0;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div><div class="ttc" id="classitk_1_1_p_s_m_particle_entropy_function_html_a97c96f778416c61de52462db16fedd11"><div class="ttname"><a href="classitk_1_1_p_s_m_particle_entropy_function.html#a97c96f778416c61de52462db16fedd11">itk::PSMParticleEntropyFunction::AngleCoefficient</a></div><div class="ttdeci">TGradientNumericType AngleCoefficient(const GradientVectorType &amp;, const GradientVectorType &amp;) const </div><div class="ttdef"><b>Definition:</b> <a href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00027">itkPSMParticleEntropyFunction.hxx:27</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab76baba9c8bcd9cf1686c00ea39c2f06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType , unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::EstimateSigma </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ParticleSystemType::PointVectorType &amp;&#160;</td>
          <td class="paramname"><em>neighborhood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point.html">PointType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimate the best sigma for Parzen windowing in a given neighborhood. The best sigma is the sigma that maximizes probability at the given point </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00062">62</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html">itkPSMParticleEntropyFunction.hxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;{</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1.0e-5;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">double</span> min_sigma = 1.0e-4;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  </div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">double</span> M = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(VDimension);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">double</span> MM = M * M * 2.0 + M;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  </div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="keywordtype">double</span> error = 1.0e6;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="keywordtype">double</span> sigma, prev_sigma;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  sigma = initial_sigma;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  </div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keywordflow">while</span> (error &gt; precision)</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a56789bd108f4f9e4f599c523bab324cf">VectorType</a> r_vec;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordtype">double</span> A = 0.0;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordtype">double</span> B = 0.0;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordtype">double</span> C = 0.0;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordtype">double</span> sigma2 = sigma * sigma;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordtype">double</span> sigma22 = sigma2 * 2.0;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    </div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; neighborhood.size(); i++)</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      <span class="keywordflow">if</span> (weights[i] &lt; epsilon) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      </div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <span class="comment">//    if ( neighborhood[i].Index == idx) continue;</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; VDimension; n++)</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        r_vec[n] = pos[n] - neighborhood[i].Point[n];</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        }</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      </div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      <span class="keywordtype">double</span> r = r_vec.magnitude();</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;      <span class="keywordtype">double</span> r2 = r*r;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      <span class="keywordtype">double</span> alpha = exp(-r2 / sigma22) * weights[i];</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      A += alpha;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      B += r2 * alpha;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      C += r2 * r2 * alpha;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      } <span class="comment">// end for i</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    prev_sigma = sigma;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    </div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordflow">if</span> (A &lt; epsilon)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      err = 1;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      <span class="keywordflow">return</span> sigma;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      }; <span class="comment">// results are not meaningful</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    </div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="comment">// First order convergence update.  This is a fixed point iteration.</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="comment">//sigma = sqrt(( 1.0 / DIM ) * ( B / A));</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    </div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="comment">// Second order convergence update (Newton-Raphson).  This is the first</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="comment">// derivative of the negative of the probability density estimation function squared over the</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <span class="comment">// second derivative.</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    </div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="comment">// old math</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="comment">//    sigma -= (sigma2 * VDimension * A * A - A  * B) / (((2.0 * sigma * VDimension) * A * A -</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="comment">//                                          (1.0/(sigma2*sigma))*(A*C-B*B)) + epsilon);</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    </div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">// New math -- results are not obviously different? </span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    sigma -= (A * (B - A * sigma2 * M)) /</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      ( (-MM * A *A * sigma) - 3.0 * A * B * (1.0 / (sigma + epsilon))</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        - (A*C + B*B) * (1.0 / (sigma2 * sigma + epsilon)) + epsilon);</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    </div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    error = 1.0 - fabs((sigma/prev_sigma));</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    </div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">// Constrain sigma.</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">if</span> (sigma &lt; min_sigma)</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;      {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;      sigma = min_sigma;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      error = precision; <span class="comment">// we are done if sigma has vanished</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;      }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;      {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      <span class="keywordflow">if</span> (sigma &lt; 0.0) sigma = min_sigma;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    </div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    } <span class="comment">// end while (error &gt; precision)</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  </div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  err = 0;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="keywordflow">return</span> sigma;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  </div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;} <span class="comment">// end estimate sigma</span></div><div class="ttc" id="classitk_1_1_p_s_m_particle_entropy_function_html_a56789bd108f4f9e4f599c523bab324cf"><div class="ttname"><a href="classitk_1_1_p_s_m_particle_entropy_function.html#a56789bd108f4f9e4f599c523bab324cf">itk::PSMParticleEntropyFunction::VectorType</a></div><div class="ttdeci">Superclass::VectorType VectorType</div><div class="ttdef"><b>Definition:</b> <a href="itk_p_s_m_particle_entropy_function_8h_source.html#l00104">itkPSMParticleEntropyFunction.h:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a857974694f2642509411e0f41a4d324c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType , unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::<a class="el" href="classitk_1_1_p_s_m_cost_function.html#aca4fea2a4b48b347792f34a483fb68e4">VectorType</a> <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::Evaluate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a8f6ac356e0de52fa2501693365e99b1a">ParticleSystemType</a> *&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The first argument is a pointer to the particle system. The second argument is the index of the domain within that particle system. The third argument is the index of the particle location within the given domain. </p>

<p>Implements <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a9b88cdcc07b341912d12fbc92968a0d2">itk::PSMCostFunction&lt; VDimension &gt;</a>.</p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00152">152</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html">itkPSMParticleEntropyFunction.hxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;{</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="comment">// Grab a pointer to the domain.  We need a Domain that has surface normal information.</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="keyword">const</span> PSMImageDomainWithGradients&lt;TGradientNumericType, VDimension&gt; *</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    domain = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>PSMImageDomainWithGradients&lt;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  TGradientNumericType, VDimension<span class="keyword">&gt;</span> *&gt;(system-&gt;GetDomain(d));</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1.0e-6;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  </div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="comment">// Retrieve the previous optimal sigma value for this point.  If the value is</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  <span class="comment">// tiny (i.e. unitialized) then use a fraction of the maximum allowed</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  <span class="comment">// neighborhood radius.</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="keywordtype">double</span> sigma = m_SpatialSigmaCache-&gt;operator[](d)-&gt;<span class="keyword">operator</span>[](idx);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="keywordflow">if</span> (sigma &lt; epsilon)</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    { sigma = m_MinimumNeighborhoodRadius / m_NeighborhoodToSigmaRatio;}</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  </div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="comment">// Determine the extent of the neighborhood that will be used in the Parzen</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="comment">// windowing estimation.  The neighborhood extent is based on the optimal</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="comment">// sigma calculation and limited to a user supplied maximum radius (probably</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="comment">// the size of the domain).</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keywordtype">double</span> neighborhood_radius = sigma * m_NeighborhoodToSigmaRatio;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="keywordflow">if</span> (neighborhood_radius &gt; m_MaximumNeighborhoodRadius)</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    { neighborhood_radius = m_MaximumNeighborhoodRadius; }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  </div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// Get the position for which we are computing the gradient.</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  PointType pos = system-&gt;GetPosition(idx, d);</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  </div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="comment">// Get the neighborhood surrounding the point &quot;pos&quot;.</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="keyword">typename</span> ParticleSystemType::PointVectorType neighborhood</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    = system-&gt;FindNeighborhoodPoints(pos, neighborhood_radius, d);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  </div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="comment">// Compute the weights based on angle between the neighbors and the center.</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  std::vector&lt;double&gt; weights;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  this-&gt;<a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a2789eb597d229e8b7c765022af18144b">ComputeAngularWeights</a>(pos,neighborhood,domain,weights);</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  </div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="comment">// Estimate the best sigma for Parzen windowing.  In some cases, such as when</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="comment">// the neighborhood does not include enough points, the value will be bogus.</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="comment">// In these cases, an error != 0 is returned, and we try the estimation again</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">// with an increased neighborhood radius.</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <span class="keywordtype">int</span> err;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  sigma =  this-&gt;<a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab76baba9c8bcd9cf1686c00ea39c2f06">EstimateSigma</a>(idx, neighborhood,weights,pos, sigma, epsilon, err);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  </div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="keywordflow">while</span> (err != 0)</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    neighborhood_radius *= 2.0;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="comment">// Constrain the neighborhood size.  If we have reached a maximum</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">// possible neighborhood size, we&#39;ll just go with that.</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordflow">if</span> ( neighborhood_radius &gt; this-&gt;GetMaximumNeighborhoodRadius())</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      {</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      sigma = this-&gt;GetMaximumNeighborhoodRadius() / this-&gt;GetNeighborhoodToSigmaRatio();</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;      neighborhood_radius =  this-&gt;GetMaximumNeighborhoodRadius();</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      sigma = neighborhood_radius / this-&gt;GetNeighborhoodToSigmaRatio();</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    </div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    neighborhood = system-&gt;FindNeighborhoodPoints(pos, neighborhood_radius, d);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    this-&gt;<a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a2789eb597d229e8b7c765022af18144b">ComputeAngularWeights</a>(pos,neighborhood,domain,weights);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    sigma = this-&gt;<a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab76baba9c8bcd9cf1686c00ea39c2f06">EstimateSigma</a>(idx, neighborhood, weights, pos, sigma, epsilon, err);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    } <span class="comment">// done while err</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  </div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="comment">// Constrain sigma to a maximum reasonable size based on the user-supplied</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="comment">// limit to neighborhood size.</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keywordflow">if</span> (sigma &gt; this-&gt;GetMaximumNeighborhoodRadius())</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    sigma = this-&gt;GetMaximumNeighborhoodRadius() / this-&gt;GetNeighborhoodToSigmaRatio();</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    neighborhood_radius = this-&gt;GetMaximumNeighborhoodRadius();</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    neighborhood = system-&gt;FindNeighborhoodPoints(pos, neighborhood_radius, d);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    this-&gt;<a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a2789eb597d229e8b7c765022af18144b">ComputeAngularWeights</a>(pos,neighborhood,domain,weights);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    }</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="comment">//  std::cout &lt;&lt; idx &lt;&lt;  &quot;\t SIGMA = &quot; &lt;&lt; sigma &lt;&lt; &quot;\t NEIGHBORHOOD SIZE = &quot; &lt;&lt; neighborhood.size()</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="comment">//            &lt;&lt; &quot;\t NEIGHBORHOOD RADIUS= &quot; &lt;&lt; neighborhood_radius &lt;&lt; std::endl;</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  </div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// We are done with the sigma estimation step.  Cache the sigma value for</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;   <span class="comment">// next time.</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   m_SpatialSigmaCache-&gt;operator[](d)-&gt;<span class="keyword">operator</span>[](idx) = sigma;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="comment">//----------------------------------------------</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160; </div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;   <span class="comment">// Compute the gradients.</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;   <span class="keywordtype">double</span> sigma2inv = 1.0 / (2.0* sigma * sigma + epsilon);</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;   <a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a56789bd108f4f9e4f599c523bab324cf">VectorType</a> r;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;   <a class="code" href="classitk_1_1_p_s_m_particle_entropy_function.html#a56789bd108f4f9e4f599c523bab324cf">VectorType</a> gradE;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; VDimension; n++)</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;     {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;     gradE[n] = 0.0;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;     }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;   </div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;   <span class="keywordtype">double</span> A = 0.0;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; neighborhood.size(); i++)</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;     {</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;     <span class="comment">//    if ( neighborhood[i].Index == idx) continue;</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;     <span class="keywordflow">if</span> (weights[i] &lt; epsilon) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;     </div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; VDimension; n++)</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;       {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;       <span class="comment">// Note that the Neighborhood object has already filtered the</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;       <span class="comment">// neighborhood for points whose normals differ by &gt; 90 degrees.</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;       r[n] = pos[n] - neighborhood[i].Point[n];</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;       }</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;     </div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;     <span class="keywordtype">double</span> q = exp( -dot_product(r, r) * sigma2inv);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;     A += q;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; VDimension; n++)</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;       {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;       gradE[n] += weights[i] * r[n] * q;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;       }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;     }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;   </div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;   <span class="keywordtype">double</span> p = 0.0;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;   <span class="keywordflow">if</span> (A &gt; epsilon)</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;     {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;     p = -1.0 / (A * sigma * sigma);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;     }</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;   </div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;   <span class="comment">// TEST</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;   <span class="comment">//   vnl_vector_fixed&lt;float, VDimension&gt; tosurf = domain-&gt;SampleGradientVnl(pos);</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;   <span class="comment">//   float tosurfmag = tosurf.magnitude() + 1.0e-5;</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;   <span class="comment">// end test</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;   <span class="comment">//   float f = domain-&gt;Sample(pos);</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt;VDimension; n++)</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;     {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;     gradE[n] *= p;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;     <span class="comment">// TEST</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;     <span class="comment">//     gradE[n] += f * (tosurf[n] / tosurfmag);</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;     <span class="comment">// end test</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;     }</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;   <span class="comment">//   maxdt = sigma * sigma;</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;   maxdt = 0.5;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;   </div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;   <span class="keywordflow">return</span> gradE;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;}</div><div class="ttc" id="classitk_1_1_p_s_m_particle_entropy_function_html_a2789eb597d229e8b7c765022af18144b"><div class="ttname"><a href="classitk_1_1_p_s_m_particle_entropy_function.html#a2789eb597d229e8b7c765022af18144b">itk::PSMParticleEntropyFunction::ComputeAngularWeights</a></div><div class="ttdeci">void ComputeAngularWeights(const PointType &amp;, const typename ParticleSystemType::PointVectorType &amp;, const PSMImageDomainWithGradients&lt; TGradientNumericType, VDimension &gt; *, std::vector&lt; double &gt; &amp;) const </div><div class="ttdef"><b>Definition:</b> <a href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00043">itkPSMParticleEntropyFunction.hxx:43</a></div></div>
<div class="ttc" id="classitk_1_1_p_s_m_particle_entropy_function_html_a56789bd108f4f9e4f599c523bab324cf"><div class="ttname"><a href="classitk_1_1_p_s_m_particle_entropy_function.html#a56789bd108f4f9e4f599c523bab324cf">itk::PSMParticleEntropyFunction::VectorType</a></div><div class="ttdeci">Superclass::VectorType VectorType</div><div class="ttdef"><b>Definition:</b> <a href="itk_p_s_m_particle_entropy_function_8h_source.html#l00104">itkPSMParticleEntropyFunction.h:104</a></div></div>
<div class="ttc" id="classitk_1_1_p_s_m_particle_entropy_function_html_ab76baba9c8bcd9cf1686c00ea39c2f06"><div class="ttname"><a href="classitk_1_1_p_s_m_particle_entropy_function.html#ab76baba9c8bcd9cf1686c00ea39c2f06">itk::PSMParticleEntropyFunction::EstimateSigma</a></div><div class="ttdeci">virtual double EstimateSigma(unsigned int, const typename ParticleSystemType::PointVectorType &amp;, const std::vector&lt; double &gt; &amp;, const PointType &amp;, double, double, int &amp;err) const </div><div class="ttdef"><b>Definition:</b> <a href="itk_p_s_m_particle_entropy_function_8hxx_source.html#l00062">itkPSMParticleEntropyFunction.hxx:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a955516abce26641103d4776f6d8bf5fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::itkNewMacro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1_p_s_m_cost_function.html#ac40d4243a5e2b4336e1f8b88ad88b6e4">Self</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for creation through the object factory. </p>

</div>
</div>
<a class="anchor" id="a43f776274c9eba3afe1c906a2b9ae894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::itkStaticConstMacro </td>
          <td>(</td>
          <td class="paramtype">Dimension&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VDimension&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dimensionality of the domain of the particle system. </p>

</div>
</div>
<a class="anchor" id="a094383aa40558ab47943f7ef29870544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::ResetBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>May be called by the solver class. </p>

<p>Reimplemented from <a class="el" href="classitk_1_1_p_s_m_cost_function.html#a06d2172ca90157b3c1715f909cd26a60">itk::PSMCostFunction&lt; VDimension &gt;</a>.</p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00133">133</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  {</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    m_SpatialSigmaCache-&gt;ZeroAllValues();</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a08fd36d130fbbf6a2ee4fb3b23e92261"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::SetFlatCutoff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The influence of particle neighbors on each other is weighted by the angle between the surface normals at their respective positions. The "flat cutoff" parameter adjusts the degree to which surface normals must differ before the weighting kicks in. Angles below the "flat cutoff" angle, which is specified in radians, are given a weighting of 1.0. Angles above this parameter value result in a lower-weight interaction between particles. Flat cutoff is set to a default value that should work for most applications. It is not necessary to set or tune this parameter unless you would like to tweak performance on a particular dataset. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00189">189</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  { m_FlatCutoff = s; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5a4d3efccb4fd97484750d1c8c0344a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::SetMaximumNeighborhoodRadius </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum radius of the neighborhood of points that are considered in the calculation. The neighborhood is a spherical radius in 3D space. MaximumNeighborhoodRadius should be set to a value equal-to or less-than the length of the largest dimension of the image. This parameter should ALWAYS be set by an application, since this class cannot know by default the size of input images. The radius value should be specified in real-world coordinates. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00173">173</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  { m_MaximumNeighborhoodRadius = s; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af6bfb82384a54f2d8f8f41f68b34203f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::SetMinimumNeighborhoodRadius </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The minimum radius of the neighborhood of points that are considered in the entropy calculation. The neighborhood is a spherical radius in 3D space. The actual radius used in a calculation may exceed this value, but will not exceed the MaximumNeighborhoodRadius. This parameter should ALWAYS be set by an application, because it must be scaled according to the spacing in the image. A good value is typically 5x the spacing of the highest-resolution dimension (the dimension with the smallest spacing. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00160">160</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  { m_MinimumNeighborhoodRadius = s; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afb8e1b9fd11d6d2c9a7cab2529b59395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::SetNeighborhoodToSigmaRatio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NeighborhoodToSigmaRatio defines the extent of a given particle's neighborhood. A particle only interacts with neighbors in this neighborhood. All other particles on the surface are ignored. The neighborhood extent is computed as a multiple of the estimated standard deviation (sigma) of the local particle positions. This parameter has a default value that should work well for most data. It is not necessary to set or tune this parameter unless you would like to tweak performance for a particular dataset. </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00203">203</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  { m_NeighborhoodToSigmaRatio = s; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a26221a57fc80d44af4eb584b0335f1f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TGradientNumericType, unsigned int VDimension&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html">itk::PSMParticleEntropyFunction</a>&lt; TGradientNumericType, VDimension &gt;::SetSpatialSigmaCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1_p_s_m_particle_entropy_function.html#ab1773d7f2f6b247826a73653920e1616">SigmaCacheType</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the cache of sigma values for each particle position. This cache is populated by registering this object as an observer of the correct particle system (see SetParticleSystem). </p>

<p>Definition at line <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html#l00211">211</a> of file <a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  {    m_SpatialSigmaCache = s;  }</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Brig/Documents/ShapeWorksStudio/src/ParticleShapeworks/include/<a class="el" href="itk_p_s_m_particle_entropy_function_8h_source.html">itkPSMParticleEntropyFunction.h</a></li>
<li>C:/Users/Brig/Documents/ShapeWorksStudio/src/ParticleShapeworks/include/<a class="el" href="itk_p_s_m_particle_entropy_function_8hxx_source.html">itkPSMParticleEntropyFunction.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 15 2016 13:48:36 for Shapeworks Studio by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
